
Следует изучить: 
	1)Pool для byte


^Легенда: @
	^		-глава
	/*		-комментарий
	...		-участок кода
	!..!	-уточненный участок
	ТД 		-тип данных

	obj 	-какой-либо объект
	arr 	-какой-либо массив
	func 	-какая-либо ф-ция
	cls 	-какой-либо класс

	<..> 	-название для объекта(или другой переменной)



^Типы данных: @

	Примитивы:
		boolean
		byte, short, int, long, char
		float, double

	Ссылочные:
		array, String, classe, interface




^Синтаксис: @

	Изменяют:
		+, -, *, /						-типичные математические действия
		% 								-остаток
		**								-степень

		=								-присваивание, возвращает новое значение слева
		+=, -=, /=, *=, //=, %=, **= 	-сразу изменяют переменную соответсвующим знаку образом	

		++, -- 							-инкремент и декремент 				
		/*до переменной - сначала изменение потом возвращение
		/*после переменной - сначала возвращение потом изменение

	Bool:
		> 			-больше
		>=			-больше или равно
		< 			-меньше
		<=			-меньше или равно
		!=			-не равно
		==			-равно
		/*Для ссылочных проверяется, указывают ли ссылки на один и тот же объект


		&&			-лог "И"	/*возвращает первое false(или последнее)
		|| 			-лог "ИЛИ" 	/*возвращает первое true (или последнее)
		! 			-лог "НЕ"



^Язык: @

	0)Комментарии/Команды:
		/**...*/ 				-для документации
		/*...*/					-многострочный
		//...					-однострочный


		static 					-
		final 					-нельзя изменять
		new 					

	1)Создание: 
		1)Одна переменная:

		3)Массив:
				ТД !имя![] 							-объявление массива 
				!имя! = new ТД[!размер!] 			-создание масcива(выделение памяти) 
				ТД !имя![] = new ТД[!размер!] 		-два в одном

				ТД !имя! = {...}  					-инициализация массива

				ТД !имя![][] = new ТД[!размер!][!размер!]	-для многомерных массивов

		4)Строка:
			String !имя!							-объявление строки

			!имя! = new String();
			!имя! = null;
			!имя! = ""; 							-создание пустой строки
			!имя! = new String("...");				-создание не пустой строки

			String !имя! = "..."; 					-инициализация

		5)Объект:
		6)Ф-ция:
		8)Глобальные сущности:

	2)Ввод/вывод:

	3)ТД: @
		1)Ф-ции:


		2)Числа:


		3)Строки:
			/*Одинаковые строковые литералы всегда ссылаются на один и тот же экземпляр класса(хранятся в String Pool)

			"..."					-обычная строка-литерал

			\n 			-символ переноса
			\u0000 		-символ шестнадцатеричного кода

	4)Условные операторы: @
		1)if:
			if(!усл!)						/*Фигурные скобки нужны если у нас больше 1ой строчки кода. Все условие пишем в скобках.
			{
				...
			}
			else if(!усл!)
			{
				...
			}
			else
			{
				...
			}

			!усл! ? !тело if! : !тело else!		-тернарный оператор
			!пер! = !усл! ? !зн1! : !зн2!	 	-присваивание через if

		2)switch:
			switch(!пер!)
			{
				case !зн!:
					...
					break
				...
				default:
			}

			break 		-выходит из switch, без него выполниться все что снизу без проверок
			default 	-выполняется если ни один break не сработал
	5)Циклы: @
		1)С предусловием:

			while(!условие!)
			{
				...
			}

		2)С постусловием:

			do
			{
				...
			} while(!условие!);

		3)С параметром:

			for(!инициализация параметров!;!условие!;!изменение параметров!(выполняется после итерации))
			{
				...
			}

			for(ТД !итерируемая пер! : arr) 	-для итер массивов

		4)break					-выход из цикла
		  break !имя метки! 	-выход из цикла с меткой		
		5)continue				-пропуск итерации
 		  continue !имя метки! 	-пропуск итерации и переход к итерации цикла с меткой	
		6)!имя метки!: !цикл! 	-создание метки для цикла


	6)Своя функция:@

		1)Создание
			/*!имя ф-ции! 	- отдельное значение(!имя ф-ции! = !имя ф-ции! -копирование ссылки ф-ции)
			/*!имя ф-ции!() - вызов ф-ции 

			1)Declaration
				function !имя ф-ии!(!параметры!)
				{
					...
				}
				/*Можно вызывать где угодно, в блоке(и нижних)

			2)Expression(ф-ция как значение)
				/*Можно вызывать только снизу; в блоке где была объявлена переменная(и нижних)

				let !имя ф-ции!
				!имя ф-ции! = function(!параметры!)
				{
					...
				};
				
				!имя ф-ции! = function !имя!(!параметры!)
				{
					...
					!имя!()
					...
				};
				/*имя для работы рекурсии даже при смене ссылок(имен ф-ции)

				let !имя ф-ции! = (!параметры!) => {...}
				let !имя ф-ции! = (!параметры!) => !зн!
				/*не имеют своего this(берут из внешнего окружения)
				/*не имеют arguments(берут из внешнего окружения)
				/*не имеют super(берут из внешнего окружения)
				/*Не могут быть вызваны с new

			3)Через конструктор:
				let !имя! = new Function("arg1", "arg2", "...argN", "functionBody")
				/*такая ф-ция имеет доступ только к глобальному окружению

			4)Параметры:
				/*Параметр функции можно приравнять к чему-либо. Тогда это значение станет дефолтом параметра(иначе undefined)
				/*Параметр - локальная переменная

				1)Умные параметры функций:
					/*Параметры на основе деструктурировавшего объекта

					function({
					  	incomingProperty: varName = defaultValue
					  	...
					}={}) 												
					{
						...
					}
					/* ={}  для удобного вызова

				2)Параметры и массивы:
					1)Остаточные параметры:

						function !имя ф-ии!(arg1, arg2, ...argN) 	-все остальные параметры передаются в массив argN
						{
							...
						}
					2)Оператор расширения:

						!имя ф-ции!(...arr) 						-массив превращается в отдельные значения 	

					3)arguments:

						function !имя ф-ии!() 						-все параметры передаются в псевдомассив
						{
							...
							arguments.lenght
							arguments[0]
							arguments[1]
							...
						}		

		2)Вызов функции
			!имя ф-ции!(!зн параметров!)

			/*Нескольким параметрам можно передавать значения:
			/*	-по порядку
			/*	-по имени(Параметр функции можно приравнять к чему-либо)
			/*	-используя оба варианта, но позиционные аргументы помещаются перед параметрами передаваемыми по имени.
			/*	(При этом значения параметров в вызове функции можно приравнивать к чему-либо в любом порядке)

		3)Возврат
			return !зн! - Функция приравнивается к этому значению и останавливается.		
			/*По дефолту функция = undefined.

		4)Замыкание:
			function !имя ф-ии!(!параметры!)
			{
				!создание чего-либо!

				return function {
					...
				}
			}
			-ф-ция создающая ф-цию с замыканием(будет обращаться к внутр окр внеш ф-ции)

			/*ф-ция запоминает свое внешнее окружение и всегда обращается к нему если нужно(кроме ф-ций созданных конструктором)
			/*каждый вызов ф-ции создает свое новое ВНУТРЕННЕЕ окружение(как и циклы)

		5)Св-ва объекта-ф-ции:
			.name 		-возвращает имя ф-ции
			.length 	-возвращает к-во параметров в объявлении
			.!имя! 		-создание своего св-ва

		6)Задержка выполнения ф-ции:
			/*КАК РАБОТАЕТ ВНУТРИ:
			/*-код выполняется строка за строкой
			/*-как доходит до таймера, то сразу запускает его и добавляет ф-цию в очередь вызовов
			/*-после прохода всего кода выполняется следующий элемент очереди
			/*-если это таймер и он закончил считать, то ф-ция в таймере запускается


			let timerId = setTimeout(funс, delay, arg1, arg2, ...) 	-ф-ция func выполниться через delay мс(возвращает индентификатор таймера)
			clearTimeout(timerId) 									-отменить 
			/*Если будет задержка 0 то выполниться сразу после выполнения текущего кода
			/*Во время отсчета выполняется код ниже

			let timerId = setInterval(func, delay, arg1, arg2, ...) -ф-ция func будет выполняться через delay мс(возвращает индентификатор таймера)
			clearInterval(timerId)									-отменить
			/*Лучше использовать рекурсивно setTimeout тк новый отсчет в этом случае будет идти после выполнения ф-ции а не старта

		7)this в ф-ции:

			this=undefined	 	-обычная ф-ция
			this=obj 	 		-метод
			this=this(внеш) 	-стрелочная ф-ция

			.call(obj, arg1, arg2, ...) 	-вызывает ф-цию с this=obj(если для метода переназначена ссылка obj->this)
			.apply(obj, args) 				-вызывает ф-цию с this=obj и псевдомассивом с аргументами

			.bind(obj [,arg1,arg2,...]) 	-возвращает «привязанный вариант» функции func, фиксируя контекст this и первые аргументы arg1, arg2…, если они заданы.
	7)Коллекции:@
		/*Все являются итерируемыми кроме объектов без спец метода
		/*К итер объектам применимы: for( of ), ...

		0)Объект:

			1)Создание:
				/*!имя объекта! = !имя объекта! 	-копируется ссылка, а не создается новый объект
				/*переменные указывающие на объект это ссылки(передача через параметры будет изменять объект)
				/*если ссылки указывают на один и тот же объект они равны по сравнению

				1)Простое:
					let !имя объекта! = {}			-создание пустого объекта

					let !имя объекта! =				-создание объекта с полями и методами
					{
						!имя св-ва!	: !зн!,
						!имя св-ва!	: [!зн!],
						"!имя св-ва!": !зн!, 		/*многословное св-во
						[!стр!] 	: !зн!,			/*вычисляемое св-во
						[!сим!] 	: !зн!, 		/*вычисляемое символьное св-во
						...
						!имя метода!(!параметры!) 
						{
							...
						}
						[!сим!](!параметры!) 
						{
							...
						}
					}

					/*имена св-в это строки(или символы)
					/*если имя записано иначе, оно преобразуется в строку

				2)Через существующие:
					1)Новый через цикл:
						let clone = {}
						// скопируем все свойства user в него
						for (let key in user) {
						  clone[key] = user[key];
						}

					2)Новый через ф-цию:
						Object.assign(!имя объекта!, !имя объекта!, ...) 								-в первый объект копируются все св-ва остальных(даже символьные)
						/*возвращает первый объект
						/*если св-во уже сущ-ет оно будет перезаписано

						let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj)) 	-клонирование с атрибутами и символами

						let clone = Object.create(Object.getPrototypeOf(obj),
						Object.getOwnPropertyDescriptors(obj))											-клон obj c тем же прототипом (с поверхностным копированием свойств)

						Object.fromEntries(arr)				- получив массив пар вида [ключ, значение], он создаёт из них объект

					3)Глубокое копирование:
						.cloneDeep(obj) 	-метод библиотеки lodash
						/*копирует и объекты в объектах

				3)Конструктор:
					function !имя ф-ции!(!параметры!)
					{
						/* this = {};  (неявно)
						...
	  					/* return this;  (неявно)
					}
					new !имя ф-ции!(!зн параметров!) 	-возвращает новый объект

					new function(!зн параметров!) 		-используется один раз
					{
						...
					}

					/*имя ф-ции с заглавной буквы

				4)Класс:

					1)Создание

						class !имя! {
						  prop = value; 				- свойство(в создаваемом объекте)
						  constructor(!арг!){...} 		- конструктор(вызываемая ф-ция)
						  method(...) {} 				- метод(в !имя!.prototype)
						  get something(...) {} 		- геттер(в !имя!.prototype)
						  set something(...) {} 		- сеттер(в !имя!.prototype)
						  [Symbol.iterator]() {} 		- метод с вычисляемым именем (здесь - символом)
						  ...

						}

						let obj = new !имя!(!арг!) 		-создание объекта с помощью класса

					2)Наследоваение
						/* !имя!.prototype.__proto__ 	== !имя класса-прототипа!.prototype
						/* !имя!.__proto__ 				== !имя класса-прототипа! 	=>статические методы и св-ва наследуются(кроме наследования у встроенных объектов)			

						class !имя! extends !имя класса-прототипа!{ ... } 	-создание с наследованием

						/*Вместо !имя класса-прототипа! может стоять ф-ция возвращающая класс-прототип

						/*При использовании методов из прототипа класс объекта не меняется 

						  static get [Symbol.species]() { 		-статический гетер который меняет класс объекта(при использовании метода из родителя создающего новый объект)
						    return !имя конструктора!;
						  }

					3)Переопределение:
						/*Если задать метод как у родителя, то будет вызываться именно он, а не от родителя
						/*При наследовании, если у класса пустой конструктор он берется из родителя
						/*Если в конструкторе используется this то обязательно использовать super(...)

						super.!имя метода!(...) 		-вызывает родительский метод.
						super(...) 						-вызывает родительский конструктор (работает только внутри нашего конструктора).

					4)Статические методы и св-ва:
						/*Являются св-вами самой ф-ции-класса

						class !имя! {
						  static prop = ...;

						  static method() {...}
						}

					5)Приватные и защищённые поля:
						/*Приватные 	- используются только при определении методов в классе(не наследуются)
						/*Защищенные 	- ...(наследуются)
						/*Реализация полей происходит через одноименные гетеры/сетеры или ф-ции 

						_!имя! 	-имя защещенного поля(соглашение)
						#!имя! 	-имя приватного поля(синтаксис)
						
						/*this['#name']  -не работает

					6)Проверка класса:
						/*работает с классами, функциями-конструкторами и для встроенных классов
						/*obj.__proto__ === Class.prototype? и далее добавляется __proto__ к объекту

						obj instanceof Class 					-вернёт true, если obj принадлежит классу Class или наследующему от него
						static [Symbol.hasInstance](obj) {...} 	-статический метод, возвращающий true\false, который вызывается при instanceof(без него - обычный проход по цепочке)

						objA.isPrototypeOf(objB) 				-возвращает true, если объект objA есть где-то в прототипной цепочке объекта objB

						{}.toString.call(obj) 					-вернет [object ...](примитивы, встроенные объекты, объекты с Symbol.toStringTag)
						[Symbol.toStringTag] 					-св-во строка, которая вставляется в [object ...]

					7)Примеси:
						/*При добавлении наследовавшей примеси-объекта super не меняется 

						Object.assign(cls.prototype, obj, ...) 		-добавление примеси к классу


			2)Свойства/Методы:

				1)Доступ:
					!имя объекта!.!имя св-ва! 			-доступ к полям
					!имя объекта!.!имя св-ва![!индекс!] -доступ к полям-Массивам

					!имя объекта!.!имя метода!()		-доступ к методам	

					!имя объекта!['!имя св-ва!']  		-динамический ключ
					/*так же подходит для многословных св-в

					/*если св-ва не существует возвращается undefined

				2)Создание/Удаление:
					!имя объекта!['!имя св-ва!'] = !зн!
					!имя объекта!.!имя св-ва! 	 = !зн!		-создание св-ва
					delete !имя объекта!.!имя св-ва! 		-удаление св-ва

					!имя объекта!.!имя метода! = !ф-ция! 	-создание метода

					!имя объекта![!символ!] = !зн! 			-создание символьного св-ва

				3)Проверка на существование:
					"!имя св-ва!" in !имя объекта! 			-false если нет
					!имя объекта!.!имя св-ва! === undefined	-true если нет(или если св-во = undefined)

				4)Цикл прохода по всем св-вам
					for(!параметр! in !имя объекта!)
					{
						...
					}
					/*параметру присваиваются имена св-в
					/*если св-ва целочисленные то они перечисляются по возрастанию

				5)Флаги и дескрипторы свойств:

					Св-ва данные:
						value 			-значение
						writable 		-можно ли изменить
						enumerable 		-можно ли перечислять в циклах
						configurable 	-можно ли удалять, изменять атрибуты(после смены на false нельзя будет вернуться)

					Св-ва аксессоры:
						get 			– функция без аргументов, которая сработает при чтении свойства,
						set 			– функция, принимающая один аргумент, вызываемая при присвоении свойства,
						enumerable 		– то же самое, что и для свойств-данных,
						configurable 	– то же самое, что и для свойств-данных.

					Object.getOwnPropertyDescriptor(obj, propertyName) 			-полная информация о св-ве, возвращает дескриптор(объект с 4-мя св-вами-атрибутами)
					Object.defineProperty(obj, propertyName, descriptor) 		-изменить флаги(по дефолту все флаги false)
					Object.defineProperties(obj, { 								-определяет мн-во св-в для объекта сразу
					  prop1: descriptor1,
					  prop2: descriptor2,
					  ...
					})
					Object.getOwnPropertyDescriptors(obj) 						-возвращает объект, содержащий все собственные дескрипторы свойств объекта.

				6)Геттеры/Сеттеры:

					let obj = {
					  get propName() {  			-геттер, срабатывает при чтении obj.propName
					    ...
					  },

					  set propName(value) { 		-сеттер, срабатывает при записи obj.propName = value
					    ... 
					  }
					};

			3)this:
				/*не фиксированный(смотрит на то что стоит слева от точки)
				/*у стрелочных функций нет своего this
				/* точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа»

				this 							-указатель на этот же объект(!имя объекта!)
				this.!имя св-ва!
				this.!имя св-ва![!индекс!]
				this.!имя метода!


			4)Опциональная цепочка:
				?. 	-проверяет объект слева, если он undefined или null вернет undefined, иначе продолжит.

				obj?.prop – возвращает obj.prop, если существует obj, и undefined в противном случае.
				obj?.[prop] – возвращает obj[prop], если существует obj, и undefined в противном случае.
				obj.method?.() – вызывает obj.method(), если существует obj.method, в противном случае возвращает undefined.

			5)ТД Символ:
				/*Символьные св-ва не видны(можно обратиться только напрямую)

				1)Создание:
					let !имя! = Symbol("!описание!") 		-создается новый несуществующий символ
					let !имя! = Symbol.for("!описание!")	-получаем переменную с символом из глобального реестра(если не было создается)

					Symbol.keyFor(!сим!) 					-возвращает описание глобального символа
					!сим!.description 						-возвращает описание любого символа

				2)Системные символы:
					Symbol.hasInstance
					Symbol.isConcatSpreadable
					Symbol.iterator							-для использования for( of )
					Symbol.toPrimitive 						-для преобразования к примитивам


			6)Преобразование к примитивам:
 				/*Что возвращать?

				/*Зависит от hint(получает "string", "number" или "default")
				1)[Symbol.toPrimitive](hint)			-метод вызывающийся при преобразовании				
				2)toString()							-если нет первого метода и hint = "string"(если его нет то valueOf())
				3)valueOf()								-если нет первого метода и hint = "number" или "default"(если его нет то toString())
							
			7)Итерируемый объект:
				/*применим к for( of ), к расширению ...

				[Symbol.iterator]() 		- метод в объекте, чтобы селать его итерируемым(возвращает объект-итератор)
				next() 						- метод в объекте-итераторе, который генерирует значения(к нему обращается for на каждой итерации)
				{done:!bool! ,value: !нов зн!}	-объект возвращаемый методом next(по нему определяются значения в цикле)


			8)Спец объекты:

				1)Map/Set
					/*Итерируемы
					/*В отличие от обычных объектов Object, перебор происходит в том же порядке, в каком происходило добавление элементов.

					1)Map:
						/*Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
						

						Методы и свойства:
						new Map() 			– создаёт и возвращает коллекцию Map(в качестве параметра может стоять Массив со Массивами(итер объект))
						Object.entries(obj)		- получает объект и возвращает массив пар ключ-значение.
						Object.fromEntries(arr)	- получив массив пар вида [ключ, значение], он создаёт из них объект

						.set(key, value) 	– записывает по ключу key значение value(возвращает новый Map)
						.get(key) 			– возвращает значение по ключу или undefined, если ключ key отсутствует.
						.has(key) 			– возвращает true, если ключ key присутствует в коллекции, иначе false.
						.delete(key) 		– удаляет элемент по ключу key.
						.clear() 			– очищает коллекцию от всех элементов.
						.size 				– возвращает текущее количество элементов.

						.forEach(func(value, key, map)) 		-выполняет ф-цию для каждой пары ключ-значение

						.keys() 			– возвращает итерируемый объект по ключам
						.values() 			– возвращает итерируемый объект по значениям
						.entries() 			– возвращает итерируемый объект по парам вида [ключ, значение](Массив со Массивами), этот вариант используется по умолчанию в for..of

					2)Set:
						/*Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

						Методы и свойства:
						new Set(iterable) 	– создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
						.add(value) 		– добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
						.delete(value) 		– удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
						.has(value) 		– возвращает true, если значение присутствует в множестве, иначе false.
						.clear() 			– удаляет все имеющиеся значения.
						.size 				– возвращает количество элементов в множестве

						.forEach(func(value, valueAgain, set)) 		-выполняет ф-цию для каждого значения

						.values() 	– возвращает перебираемый объект для значений,
						.keys()		– возвращает перебираемый объект для значений,
						.entries() 	– возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map

				2)WeakMap/WeakSet
					/*Используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта.
					/*Подобны Map и Set
					/*Не Итерируемы
					/*В качестве ключей(значений у WeakSet) только объекты, и автоматически удаляющая их вместе с соответствующими значениями, 
					/*как только они становятся недостижимыми иными путями.

					/*Не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. 
					/*Возможны только операции на отдельном элементе коллекции.

				3)Date:
					/*Есть автоисправление даты
					/*Январь и воскресенье - 0
					/*ТАЙМСТАМП - количество миллисекунд, прошедших с 1 января 1970 года UTC+0

					1)Создание
						Date.now() 			
						new Date() 					-возвращает текущие дату и время

						new Date(milliseconds)		-возвращает дату и время после количества миллисекунд, прошедших с 1 января 1970 года UTC+0
						new Date(datestring) 		-возвращает дату и время по строке(и времени 00:00 по Гринвичу) в соответствии с текущим временем
						new Date(year, month, date, hours, minutes, seconds, ms) 	-возвращает дату и время по параметрам(первые два обязательны) 
						Date.parse(str)  		 	-возвращает таймстамп по строке YYYY-MM-DDTHH:mm:ss.sssZ

					2)Дата как число(таймстамп)
						/*при преобразовании в число объект Date становится таймстампом

						.getTime()
						+date 				-преобразуют дату date в число таймстамп

						date1 - date2 		-получается разница в миллисекундах м/у датами

				4)JSON:
					/*общий формат для представления значений и объектов
					/*JSON строка - строгая строка как выглядит объект или значение

					1)В JSON
						JSON.stringify(value, rep, space) 	-возвращает JSON строку(value -обязательно)
							rep 							-массив свойств для кодирования или ф-ция соответствия function(key, value)
							space 							-отступы, используемое для форматирования(красивый вывод)
						/*не работает с циклическими ссылками(только с использованием replacer)

						toJSON()  									-метод в объекте для своего преобразования в JSON при вызове JSON.stringify()

					2)ИЗ JSON
						JSON.parse(str, reviver)			-возвращает объект из JSON строки(str -обязательно)
							reviver 						-ф-ция function(key, value) для правильных значений в объекте(например для даты)
					
				5)ArrayBuffer/TypedArray/DataView/TextEncoder/TextDecoder

			9)Список:
				/*объект со св-ом которое ссылается на этот же объект

				1)Создание:

					let list = {
						...
						next->list
					}


			10)Прототипное наследование:
				/*__proto__     - св-во в каждом объекте(ссылка на другой объект-прототип; дефолт = Object.prototype, Array.prototype ...)
				/*При отсутствии св-ва берется из прототипа(может быть цепочкой)
				/*Прототип используется только для чтения свойств(св-ва-аксессоры исключение)

				obj1.__proto__ = obj2 		-задать прототип

				/*prototype 	- св-во в каждой ф-ции-конструкторе(ссылка на объект, который станет прототипом; дефолт = {constructor: Func})
				/*Если prototype у конструктора не было изменено, то мы сможем получать констуктор объекта через св-во constructor

				Func.prototype = obj 		-задать прототип создаваемым ф-циям

				/*Все методы объектов и примитивов хранятся в их прототипах Number.prototype, Array.prototype ... (все наследуются от Object.prototype)



				Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
				Object.getPrototypeOf(obj) 			– возвращает свойство [[Prototype]] объекта obj.
				Object.setPrototypeOf(obj, proto) 	– устанавливает свойство [[Prototype]] объекта obj как proto.

				Object.create(null) 				- создание объекта без прототипов(__proto__ -как обычное св-во)

		1)Массивы:
			/*В Массиве могут храниться элементы любого типа
			/*Быстрее работает с упорядоченными данными

			1)Создание/Удаление
				/*Является объектом поэтому 
				/*!имя Массива! = !имя Массива! 	-копируется ссылка, а не создается новый Массив

				let !имя массива! 		= [!зн-я!]		
				let !имя массива! 		= new Array(!зн-я!) -инициализация				/*если указано одно число то создастся пустой с этой длинной
				let !имя массива! 		= []	
				let !имя массива! 		= new Array() 		-создание пустых Массивов

				let !имя массива! = arr.slice() 	-создание копии arr

				!имя массива!.length = 0 			-удаление массива

			2)Элементы:

				!имя массива![!индекс!]						-взятие значения в ячейке
				!имя массива![!индекс!] = !значение!		-смена значения в ячейке(или добавление)

				for( of ) 									-цикл для элементов Массива

				delete !имя массива![!индекс!] 				-удаление элемента(без сдвига)

		2)Строки:
			/*нельзя изменять

			1)Создание
				!имя строки! = '...'
				!имя строки! = "..."
				!имя строки! = `...${!значение!}...` -строка со значением переведенным в строку /*возможен перенос строки

			2)Символы:
				!стр![!инд!]			-взятие одного символа строки /* !стр!.charAt(!инд!) -всегда вернет строку
				for( of ) 				-цикл для символов строк

			3)Регулярные выражения:

				1)Создание
					new RegExp(!pattern!, !flags!) 		
					/!pattern!/!flags! 					-возвращает регулярное выражение

				2)Флаги

					i 	-поиск не зависит от регистра
					g 	-поиск ищет все совпадения, без него – только первое.
					m 	-многострочный режим
					s 	-включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n
					u 	-включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар
					y 	-режим поиска на конкретной позиции в тексте

				3)Методы

					!str!
						.match(regexp) 					-возвращает массив совпадений(без g - массив с одним значением) либо null.
							.index
							.input
						.replace(regexp, replacement) 	-заменяет совпадения

					replacement
						$&		-вставляет всё найденное совпадение
						$`	 	-вставляет часть строки до совпадения
						$'		-вставляет часть строки после совпадения
						$n		-если n это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения
						$<name>	-вставляет содержимое скобочной группы с именем name
						$$		-вставляет символ "$"



					!regexp!
						.test(str) 				-если есть совпадение вернет true иначе false

				4)Символьные классы:

					\d 	– цифры.
					\D 	– не цифры.
					\s 	– пробельные символы, табы, новые строки.
					\S 	– все, кроме \s.
					\w 	– латиница, цифры, подчёркивание '_'.
					\W 	– все, кроме \w.
					. 	– любой символ, если с флагом регулярного выражения s, в противном случае любой символ, кроме перевода строки \n.

	8)Методы и св-ва:

		1)Массив

			1)ВОЗВРАЩЕНИЕ НА ОСНОВЕ МАССИВА

				.length					-возвращает длину

				


			2)ДЛЯ ДОБАВЛЕНИЯ/УДАЛЕНИЯ ЭЛЕМЕНТОВ




			3)ДЛЯ ПОИСКА СРЕДИ ЭЛЕМЕНТОВ

				

			
			4)ДЛЯ ПРЕОБРАЗОВАНИЯ МАССИВА


		2)Строка

			1)ВОЗВРАЩЕНИЕ НА ОСНОВЕ СТРОКИ

				.substring(start, end)	-возвращает часть строки между start и end

				.equals(str) 			-возвращает true если строки совпадают посимвольно

				.intern() 				-возвращает ссылку на пул



			2)ДЛЯ ПОИСКА СРЕДИ СИМВОЛОВ

			3)



		3)Число


^Особенности/Определения:

^Библиотеки/Фреймверки/...:

^Алгоритмы: