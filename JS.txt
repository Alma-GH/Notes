
Следует изучить: 

	4)live scss
	5)prettier
	6)webpack


^Легенда:
	^		-глава
	/*		-комментарий
	...		-участок кода
	!..!	-уточненный участок
	ТД 		-тип данных

	obj 	-какой-либо объект
	arr 	-какой-либо массив
	func 	-какая-либо ф-ция
	cls 	-какой-либо класс

	<..> 	-название для объекта(или другой переменной)



^Типы данных:

	number
		int
		float
		Infinity 
		-Infinity 
		NaN 		-вычислительная ошибка(не является равным ни чему другому, даже самому себе)
	string
	boolean
	object 			-все объекты имеют ссылочную систему
		function
		array
		map
		set
		date
	symbol
	bigint

	undefined		-значение не было присвоено
	null 			-ничего



^Синтаксис:

	Изменяют:
		+, -, *, /						-типичные математические действия
		% 								-остаток
		**								-степень


		+ 								-унарный преобразует в число
		!! 								-преобразует в логику
		^0 								-отбрасыывает дробную часть

		=								-присваивание, возвращает новое значение слева
		+=, -=, /=, *=, //=, %=, **= 	-сразу изменяют переменную соответсвующим знаку образом	

		++, -- 							-инкремент и декремент 				
		/*до переменной - сначала изменение потом возвращение
		/*после переменной - сначала возвращение потом изменение


		... 		-расширение, раскладывает итер объект на его элементы

	Bool:
		> 			-больше
		>=			-больше или равно
		< 			-меньше
		<=			-меньше или равно
		!=			-не равно
		==			-равно
		===			-абсолютное равно(смотрит и на типы) 				
		/*NaN != NaN

		&&			-лог "И"	/*возвращает первое false(или последнее)
		|| 			-лог "ИЛИ" 	/*возвращает первое true (или последнее)
		! 			-лог "НЕ"

		?? 			-возвращает первое определенное(НЕ null,undefined)
		.
		?.

		of			-есть ли в наличии в массиве(для последовательностей)
		in  		-есть ли св-во в объекте
		instanceof 	-принадлежит ли классу или наследующему от него

	Приоритеты:
		(..)
		+,-



^Язык:

	0)Комментарии/Команды:
		/*...*/					-многострочный
		//...					-однострочный

		debugger 				-код останавливается
		delete 					-удаление
		typeof					-вывод ТД в виде строки

		new 					-запуск конструктора

		super
		import

		let 
		const
		var 					
		/*var уже не используется; отличия:
		/*-не существует блочной области видимости(видна в блоках выше), но ограничивается ф-циями
		/*-обрабатываются в начале запуска функции или скрипта(без инициализации)
	1)Создание:
		1)Одна переменная:
			const !имя! = !значение!		-создание константы(инициализация обязательна)
			let !имя!						-создание переменной(любой изменяющийся объект)				
			/* let !имя! = !значение!	-инициализация(создание + присваивание)
		2)Деструктуризация:
			let [item1 = default, item2, ...rest] 	= array 	-создание переменных на основе итерируемого объекта(rest-Массив из оставшихся)
			let {prop : varName = default, ...rest} = object 	-создание переменных на основе объекта(rest-объект из оставшихся)
			/*без let записывается в сущ-е переменные(+ ({}=obj)  )
			/*Вложенности прямо прописываются(вместо элементов внутри - переменные)
		3)Массив:
				let !имя массива! 		= [!зн-я!]		
				let !имя массива! 		= new Array(!зн-я!) -инициализация				/*если указано одно число то создастся пустой с этой длинной
				let !имя массива! 		= []	
				let !имя массива! 		= new Array() 		-создание пустых Массивов
		4)Строка:
		5)Объект:
		6)Ф-ция:
		7)Блок:
			{
				...
			}
			/*блоки так же создаются у условий и циклов(множество раз)
		8)Глобальные сущности:
			window.!сущность! = ... 	-создание
			window.!сущность! 			-доступ

		/* При создании доступно для данного и нижних блоков
		/* Изменения в блоке работают глобально
		/* Если создается вне всех блоков, доступно для всех скриптов(все скрипты связаны)
	2)Ввод/вывод:
		alert(..)			-выводит на сайт сообщение

		prompt(..) 			-ввод из сайта в JS(возвращает введенное значение)

		confirm(..) 		-возвращает true или false
		
		console.log(..)
		console.dir(..)		-отображает список свойств указанного объекта
		console.error(..)	-выводит как ошибку
	3)ТД:
		1)Перевод и проверка:
			String(!зн!) 		-возвращает строку
			Number(!зн!) 		-возвращает число 	/*+  !зн!
			Boolean(!зн!) 		-возвращает логику	/*!! !зн!

			typeof(..) 			-возвращает строку с названием ТД(примитивы)
			/*БАГ для null возвращает object
		
			{}.toString.call(obj) 	-возвращает строку с названием ТД(примитивы, встроенные объекты, объекты с Symbol.toStringTag)

			obj instanceof Class	-вернёт true, если obj принадлежит классу Class или наследующему от него

		2)Числа:
			!число!e!степень! 				-!число! умноженное на 10^!степень!
			!число!_!продолжение числа! 	-удобная запись

			0x!число! 			- 16-ое
			0o!число!			- 8-ое
			0b!число! 			- 2-ое

			Math.random()			-возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)
			Math.max(a, b, c...) 	-возвращает наибольшее число из перечисленных аргументов.
			Math.min(a, b, c...) 	-возвращает наименьшее число из перечисленных аргументов.
			Math.pow(n, power)     	-возвращает число n, возведённое в степень power

			Math.floor()			-округление в меньшую сторону
			Math.ceil()				-округление в большую сторону
			Math.round()			-округление до ближайшего целого
			Math.trunc() 			-производит удаление дробной части без округления 	/*не поддерживается в Internet Explorer + ^0

			parseInt() 				-возвращает целое число из строки(по основанию)
			parseFloat() 			-возвращает число с плавающей точкой из строки

		3)Строки:
			/*сравниваются по коду

			'...'
			"..."					-обычная строка
			`...${!значение!}...`	-строка со значением переведенным в строку(+возможен перенос строки)

			\n 			-символ переноса
			\u0000 		-символ шестнадцатеричного кода

	4)Условные операторы:
		1)if:
			if(!усл!)						/*Фигурные скобки нужны если у нас больше 1ой строчки кода. Все условие пишем в скобках.
			{
				...
			}
			else if(!усл!)
			{
				...
			}
			else
			{
				...
			}

			!усл! ? !тело if! : !тело else!		-тернарный оператор
			!пер! = !усл! ? !зн1! : !зн2!	 	-присваивание через if

		2)switch:
			switch(!пер!)
			{
				case !зн!:
					...
					break
				...
				default:
			}

			break 		-выходит из switch, без него выполниться все что снизу без проверок
			default 	-выполняется если ни один break не сработал
	5)Циклы:
		1)С предусловием:

			while(!условие!)
			{
				...
			}

		2)С постусловием:

			do
			{
				...
			} while(!условие!);

		3)С параметром:

			for(!инициализация параметров!;!условие!;!изменение параметров!(выполняется после итерации))
			{
				...
			}

			for( in )	-для св-в объектов(собс и унасл)
			for( of ) 	-для итер объектов(строка, массив)

		4)break					-выход из цикла
		  break !имя метки! 	-выход из цикла с меткой		
		5)continue				-пропуск итерации
 		  continue !имя метки! 	-пропуск итерации и переход к итерации цикла с меткой	
		6)!имя метки!: !цикл! 	-создание метки для цикла


	6)Своя функция:

		1)Создание
			/*!имя ф-ции! 	- отдельное значение(!имя ф-ции! = !имя ф-ции! -копирование ссылки ф-ции)
			/*!имя ф-ции!() - вызов ф-ции 

			1)Declaration
				function !имя ф-ии!(!параметры!)
				{
					...
				}
				/*Можно вызывать где угодно, в блоке(и нижних)

			2)Expression(ф-ция как значение)
				/*Можно вызывать только снизу; в блоке где была объявлена переменная(и нижних)

				let !имя ф-ции!
				!имя ф-ции! = function(!параметры!)
				{
					...
				};
				
				!имя ф-ции! = function !имя!(!параметры!)
				{
					...
					!имя!()
					...
				};
				/*имя для работы рекурсии даже при смене ссылок(имен ф-ции)

				let !имя ф-ции! = (!параметры!) => {...}
				let !имя ф-ции! = (!параметры!) => !зн!
				/*не имеют своего this(берут из внешнего окружения)
				/*не имеют arguments(берут из внешнего окружения)
				/*не имеют super(берут из внешнего окружения)
				/*Не могут быть вызваны с new

			3)Через конструктор:
				let !имя! = new Function("arg1", "arg2", "...argN", "functionBody")
				/*такая ф-ция имеет доступ только к глобальному окружению

			4)Параметры:
				/*Параметр функции можно приравнять к чему-либо. Тогда это значение станет дефолтом параметра(иначе undefined)
				/*Параметр - локальная переменная

				1)Умные параметры функций:
					/*Параметры на основе деструктурировавшего объекта

					function({
					  	incomingProperty: varName = defaultValue
					  	...
					}={}) 												
					{
						...
					}
					/* ={}  для удобного вызова

				2)Параметры и массивы:
					1)Остаточные параметры:

						function !имя ф-ии!(arg1, arg2, ...argN) 	-все остальные параметры передаются в массив argN
						{
							...
						}
					2)Оператор расширения:

						!имя ф-ции!(...arr) 						-массив превращается в отдельные значения 	

					3)arguments:

						function !имя ф-ии!() 						-все параметры передаются в псевдомассив
						{
							...
							arguments.lenght
							arguments[0]
							arguments[1]
							...
						}		

		2)Вызов функции
			!имя ф-ции!(!зн параметров!)

			/*Нескольким параметрам можно передавать значения:
			/*	-по порядку
			/*	-по имени(Параметр функции можно приравнять к чему-либо)
			/*	-используя оба варианта, но позиционные аргументы помещаются перед параметрами передаваемыми по имени.
			/*	(При этом значения параметров в вызове функции можно приравнивать к чему-либо в любом порядке)

		3)Возврат
			return !зн! - Функция приравнивается к этому значению и останавливается.		
			/*По дефолту функция = undefined.

		4)Замыкание:
			function !имя ф-ии!(!параметры!)
			{
				!создание чего-либо!

				return function (){
					...
				}
			}
			-ф-ция создающая ф-цию с замыканием(будет обращаться к внутр окр внеш ф-ции)

			/*ф-ция запоминает свое внешнее окружение и всегда обращается к нему если нужно(кроме ф-ций созданных конструктором)
			/*каждый вызов ф-ции создает свое новое ВНУТРЕННЕЕ окружение(как и циклы)

		5)Св-ва объекта-ф-ции:
			.name 		-возвращает имя ф-ции
			.length 	-возвращает к-во параметров в объявлении
			.!имя! 		-создание своего св-ва

		6)Задержка выполнения ф-ции:
			/*КАК РАБОТАЕТ ВНУТРИ:
			/*-код выполняется строка за строкой
			/*-как доходит до таймера, то сразу запускает его и добавляет ф-цию в очередь вызовов
			/*-после прохода всего кода выполняется следующий элемент очереди
			/*-если это таймер и он закончил считать, то ф-ция в таймере запускается


			let timerId = setTimeout(funс, delay, arg1, arg2, ...) 	-ф-ция func выполниться через delay мс(возвращает индентификатор таймера)
			clearTimeout(timerId) 									-отменить 
			/*Если будет задержка 0 то выполниться сразу после выполнения текущего кода
			/*Во время отсчета выполняется код ниже

			let timerId = setInterval(func, delay, arg1, arg2, ...) -ф-ция func будет выполняться через delay мс(возвращает индентификатор таймера)
			clearInterval(timerId)									-отменить
			/*Лучше использовать рекурсивно setTimeout тк новый отсчет в этом случае будет идти после выполнения ф-ции а не старта

		7)this в ф-ции:

			this=undefined	 	-обычная ф-ция(=window если в браузере)
			this=obj 	 		-метод
			this=this(внеш) 	-стрелочная ф-ция

			.call(obj, arg1, arg2, ...) 	-вызывает ф-цию с this=obj(если для метода переназначена ссылка obj->this)
			.apply(obj, args) 				-вызывает ф-цию с this=obj и псевдомассивом с аргументами

			.bind(obj [,arg1,arg2,...]) 	-возвращает «привязанный вариант» функции func, фиксируя контекст this и первые аргументы arg1, arg2…, если они заданы.
			/* После привязки this и args не может измениться
			/* Привязанный вариант берет следующие аргументы(те что не заданы в bind)

	7)Коллекции:
		/*Все являются итерируемыми кроме объектов без спец метода
		/*К итер объектам применимы: for( of ), ...

		0)Объект:

			1)Создание:
				/*!имя объекта! = !имя объекта! 	-копируется ссылка, а не создается новый объект
				/*переменные указывающие на объект это ссылки(передача через параметры будет изменять объект)
				/*если ссылки указывают на один и тот же объект они равны по сравнению

				1)Простое:
					let !имя объекта! = {}			-создание пустого объекта

					let !имя объекта! =				-создание объекта с полями и методами
					{
						!имя св-ва!	: !зн!,
						!имя св-ва!	: [!зн!],
						"!имя св-ва!": !зн!, 		/*многословное св-во
						[!стр!] 	: !зн!,			/*вычисляемое св-во
						[!сим!] 	: !зн!, 		/*вычисляемое символьное св-во
						...
						!имя метода!(!параметры!) 
						{
							...
						}
						[!сим!](!параметры!) 
						{
							...
						}
					}

					/*имена св-в это строки(или символы)
					/*если имя записано иначе, оно преобразуется в строку

				2)Через существующие:
					1)Новый через цикл:
						let clone = {}
						// скопируем все свойства user в него
						for (let key in user) {
						  clone[key] = user[key];
						}

					2)Новый через ф-цию:
						Object.assign(!имя объекта!, !имя объекта!, ...) 								-в первый объект копируются все св-ва остальных(даже символьные)
						/*возвращает первый объект
						/*если св-во уже сущ-ет оно будет перезаписано

						let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj)) 	-клонирование с атрибутами и символами

						let clone = Object.create(Object.getPrototypeOf(obj),
						Object.getOwnPropertyDescriptors(obj))											-клон obj c тем же прототипом (с поверхностным копированием свойств)

						Object.fromEntries(arr)				- получив массив пар вида [ключ, значение], он создаёт из них объект

					3)Глубокое копирование:
						.cloneDeep(obj) 	-метод библиотеки lodash
						/*копирует и объекты в объектах

				3)Конструктор:
					function !имя ф-ции!(!параметры!)
					{
						/* this = {};  (неявно)
						...
	  					/* return this;  (неявно)
					}
					new !имя ф-ции!(!зн параметров!) 	-возвращает новый объект

					new function(!зн параметров!) 		-используется один раз
					{
						...
					}

					/*имя ф-ции с заглавной буквы

				4)Класс:

					1)Создание

						class !имя! {
						  prop = value; 				- свойство(в создаваемом объекте)
						  constructor(!арг!){...} 		- конструктор(вызываемая ф-ция)
						  method(...) {} 				- метод(в !имя!.prototype)
						  get something(...) {} 		- геттер(в !имя!.prototype)
						  set something(...) {} 		- сеттер(в !имя!.prototype)
						  [Symbol.iterator]() {} 		- метод с вычисляемым именем (здесь - символом)
						  ...

						}

						let obj = new !имя!(!арг!) 		-создание объекта с помощью класса

					2)Наследоваение
						/* !имя!.prototype.__proto__ 	== !имя класса-прототипа!.prototype
						/* !имя!.__proto__ 				== !имя класса-прототипа! 	=>статические методы и св-ва наследуются(кроме наследования у встроенных объектов)			

						class !имя! extends !имя класса-прототипа!{ ... } 	-создание с наследованием

						/*Вместо !имя класса-прототипа! может стоять ф-ция возвращающая класс-прототип

						/*При использовании методов из прототипа класс объекта не меняется 

						  static get [Symbol.species]() { 		-статический гетер который меняет класс объекта(при использовании метода из родителя создающего новый объект)
						    return !имя конструктора!;
						  }

					3)Переопределение:
						/*Если задать метод как у родителя, то будет вызываться именно он, а не от родителя
						/*При наследовании, если у класса пустой конструктор он берется из родителя
						/*Если в конструкторе используется this то обязательно использовать super(...)

						super.!имя метода!(...) 		-вызывает родительский метод.
						super(...) 						-вызывает родительский конструктор (работает только внутри нашего конструктора).

					4)Статические методы и св-ва:
						/*Являются св-вами самой ф-ции-класса

						class !имя! {
						  static prop = ...;

						  static method() {...}
						}

					5)Приватные и защищённые поля:
						/*Приватные 	- используются только при определении методов в классе(не наследуются)
						/*Защищенные 	- ...(наследуются)
						/*Реализация полей происходит через одноименные гетеры/сетеры или ф-ции 

						_!имя! 	-имя защещенного поля(соглашение)
						#!имя! 	-имя приватного поля(синтаксис)
						
						/*this['#name']  -не работает

					6)Проверка класса:
						/*работает с классами, функциями-конструкторами и для встроенных классов
						/*obj.__proto__ === Class.prototype? и далее добавляется __proto__ к объекту

						obj instanceof Class 					-вернёт true, если obj принадлежит классу Class или наследующему от него
						static [Symbol.hasInstance](obj) {...} 	-статический метод, возвращающий true\false, который вызывается при instanceof(без него - обычный проход по цепочке)

						objA.isPrototypeOf(objB) 				-возвращает true, если объект objA есть где-то в прототипной цепочке объекта objB

						{}.toString.call(obj) 					-вернет [object ...](примитивы, встроенные объекты, объекты с Symbol.toStringTag)
						[Symbol.toStringTag] 					-св-во строка, которая вставляется в [object ...]

					7)Примеси:
						/*При добавлении наследовавшей примеси-объекта super не меняется 

						Object.assign(cls.prototype, obj, ...) 		-добавление примеси к классу


			2)Свойства/Методы:

				1)Доступ:
					!имя объекта!.!имя св-ва! 			-доступ к полям
					!имя объекта!.!имя св-ва![!индекс!] -доступ к полям-Массивам

					!имя объекта!.!имя метода!()		-доступ к методам	

					!имя объекта!['!имя св-ва!']  		-динамический ключ
					/*так же подходит для многословных св-в

					/*если св-ва не существует возвращается undefined

				2)Создание/Удаление:
					!имя объекта!['!имя св-ва!'] = !зн!
					!имя объекта!.!имя св-ва! 	 = !зн!		-создание св-ва
					delete !имя объекта!.!имя св-ва! 		-удаление св-ва

					!имя объекта!.!имя метода! = !ф-ция! 	-создание метода

					!имя объекта![!символ!] = !зн! 			-создание символьного св-ва

				3)Проверка на существование:
					"!имя св-ва!" in !имя объекта! 			-false если нет
					!имя объекта!.!имя св-ва! === undefined	-true если нет(или если св-во = undefined)

				4)Цикл прохода по всем св-вам
					for(!параметр! in !имя объекта!)
					{
						...
					}
					/*параметру присваиваются имена св-в
					/*если св-ва целочисленные то они перечисляются по возрастанию

				5)Флаги и дескрипторы свойств:

					Св-ва данные:
						value 			-значение
						writable 		-можно ли изменить
						enumerable 		-можно ли перечислять в циклах
						configurable 	-можно ли удалять, изменять атрибуты(после смены на false нельзя будет вернуться)

					Св-ва аксессоры:
						get 			– функция без аргументов, которая сработает при чтении свойства,
						set 			– функция, принимающая один аргумент, вызываемая при присвоении свойства,
						enumerable 		– то же самое, что и для свойств-данных,
						configurable 	– то же самое, что и для свойств-данных.

					Object.getOwnPropertyDescriptor(obj, propertyName) 			-полная информация о св-ве, возвращает дескриптор(объект с 4-мя св-вами-атрибутами)
					Object.defineProperty(obj, propertyName, descriptor) 		-изменить флаги(по дефолту все флаги false)
					Object.defineProperties(obj, { 								-определяет мн-во св-в для объекта сразу
					  prop1: descriptor1,
					  prop2: descriptor2,
					  ...
					})
					Object.getOwnPropertyDescriptors(obj) 						-возвращает объект, содержащий все собственные дескрипторы свойств объекта.

				6)Геттеры/Сеттеры:

					let obj = {
					  get propName() {  			-геттер, срабатывает при чтении obj.propName
					    ...
					  },

					  set propName(value) { 		-сеттер, срабатывает при записи obj.propName = value
					    ... 
					  }
					};

			3)this:
				/*не фиксированный(смотрит на то что стоит слева от точки)
				/*у стрелочных функций нет своего this
				/* точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа»

				this 							-указатель на этот же объект(!имя объекта!)
				this.!имя св-ва!
				this.!имя св-ва![!индекс!]
				this.!имя метода!


			4)Опциональная цепочка:
				?. 	-проверяет объект слева, если он undefined или null вернет undefined, иначе продолжит.

				obj?.prop – возвращает obj.prop, если существует obj, и undefined в противном случае.
				obj?.[prop] – возвращает obj[prop], если существует obj, и undefined в противном случае.
				obj.method?.() – вызывает obj.method(), если существует obj.method, в противном случае возвращает undefined.

			5)ТД Символ:
				/*Символьные св-ва не видны(можно обратиться только напрямую)

				1)Создание:
					let !имя! = Symbol("!описание!") 		-создается новый несуществующий символ
					let !имя! = Symbol.for("!описание!")	-получаем переменную с символом из глобального реестра(если не было создается)

					Symbol.keyFor(!сим!) 					-возвращает описание глобального символа
					!сим!.description 						-возвращает описание любого символа

				2)Системные символы:
					Symbol.hasInstance
					Symbol.isConcatSpreadable
					Symbol.iterator							-для использования for( of )
					Symbol.toPrimitive 						-для преобразования к примитивам


			6)Преобразование к примитивам:
 				/*Что возвращать?

				/*Зависит от hint(получает "string", "number" или "default")
				1)[Symbol.toPrimitive](hint)			-метод вызывающийся при преобразовании				
				2)toString()							-если нет первого метода и hint = "string"(если его нет то valueOf())
				3)valueOf()								-если нет первого метода и hint = "number" или "default"(если его нет то toString())
							
			7)Итерируемый объект:
				/*применим к for( of ), к расширению ...

				[Symbol.iterator]() 		- метод в объекте, чтобы селать его итерируемым(возвращает объект-итератор)
				next() 						- метод в объекте-итераторе, который генерирует значения(к нему обращается for на каждой итерации)
				{done:!bool! ,value: !нов зн!}	-объект возвращаемый методом next(по нему определяются значения в цикле)


			8)Спец объекты:

				1)Map/Set
					/*Итерируемы
					/*В отличие от обычных объектов Object, перебор происходит в том же порядке, в каком происходило добавление элементов.

					1)Map:
						/*Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
						

						Методы и свойства:
						new Map() 			– создаёт и возвращает коллекцию Map(в качестве параметра может стоять Массив со Массивами(итер объект))
						Object.entries(obj)		- получает объект и возвращает массив пар ключ-значение.
						Object.fromEntries(arr)	- получив массив пар вида [ключ, значение], он создаёт из них объект

						.set(key, value) 	– записывает по ключу key значение value(возвращает новый Map)
						.get(key) 			– возвращает значение по ключу или undefined, если ключ key отсутствует.
						.has(key) 			– возвращает true, если ключ key присутствует в коллекции, иначе false.
						.delete(key) 		– удаляет элемент по ключу key.
						.clear() 			– очищает коллекцию от всех элементов.
						.size 				– возвращает текущее количество элементов.

						.forEach(func(value, key, map)) 		-выполняет ф-цию для каждой пары ключ-значение

						.keys() 			– возвращает итерируемый объект по ключам
						.values() 			– возвращает итерируемый объект по значениям
						.entries() 			– возвращает итерируемый объект по парам вида [ключ, значение](Массив со Массивами), этот вариант используется по умолчанию в for..of

					2)Set:
						/*Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

						Методы и свойства:
						new Set(iterable) 	– создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
						.add(value) 		– добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
						.delete(value) 		– удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
						.has(value) 		– возвращает true, если значение присутствует в множестве, иначе false.
						.clear() 			– удаляет все имеющиеся значения.
						.size 				– возвращает количество элементов в множестве

						.forEach(func(value, valueAgain, set)) 		-выполняет ф-цию для каждого значения

						.values() 	– возвращает перебираемый объект для значений,
						.keys()		– возвращает перебираемый объект для значений,
						.entries() 	– возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map

				2)WeakMap/WeakSet
					/*Используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта.
					/*Подобны Map и Set
					/*Не Итерируемы
					/*В качестве ключей(значений у WeakSet) только объекты, и автоматически удаляющая их вместе с соответствующими значениями, 
					/*как только они становятся недостижимыми иными путями.

					/*Не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. 
					/*Возможны только операции на отдельном элементе коллекции.

				3)Date:
					/*Есть автоисправление даты
					/*Январь и воскресенье - 0
					/*ТАЙМСТАМП - количество миллисекунд, прошедших с 1 января 1970 года UTC+0

					1)Создание
						Date.now() 			
						new Date() 					-возвращает текущие дату и время

						new Date(milliseconds)		-возвращает дату и время после количества миллисекунд, прошедших с 1 января 1970 года UTC+0
						new Date(datestring) 		-возвращает дату и время по строке(и времени 00:00 по Гринвичу) в соответствии с текущим временем
						new Date(year, month, date, hours, minutes, seconds, ms) 	-возвращает дату и время по параметрам(первые два обязательны) 
						Date.parse(str)  		 	-возвращает таймстамп по строке YYYY-MM-DDTHH:mm:ss.sssZ

					2)Дата как число(таймстамп)
						/*при преобразовании в число объект Date становится таймстампом

						.getTime()
						+date 				-преобразуют дату date в число таймстамп

						date1 - date2 		-получается разница в миллисекундах м/у датами

				4)JSON:
					/*общий формат для представления значений и объектов
					/*JSON строка - строгая строка как выглядит объект или значение

					1)В JSON
						JSON.stringify(value, rep, space) 	-возвращает JSON строку(value -обязательно)
							rep 							-массив свойств для кодирования или ф-ция соответствия function(key, value)
							space 							-отступы, используемое для форматирования(красивый вывод)
						/*не работает с циклическими ссылками(только с использованием replacer)

						toJSON()  									-метод в объекте для своего преобразования в JSON при вызове JSON.stringify()

					2)ИЗ JSON
						JSON.parse(str, reviver)			-возвращает объект из JSON строки(str -обязательно)
							reviver 						-ф-ция function(key, value) для правильных значений в объекте(например для даты)
					
				5)ArrayBuffer/TypedArray/DataView/TextEncoder/TextDecoder

			9)Список:
				/*объект со св-ом которое ссылается на этот же объект

				1)Создание:

					let list = {
						...
						next->list
					}


			10)Прототипное наследование:
				/*__proto__     - св-во в каждом объекте(ссылка на другой объект-прототип; дефолт = Object.prototype, Array.prototype ...)
				/*При отсутствии св-ва берется из прототипа(может быть цепочкой)
				/*Прототип используется только для чтения свойств(св-ва-аксессоры исключение)

				obj1.__proto__ = obj2 		-задать прототип

				/*prototype 	- св-во в каждой ф-ции-конструкторе(ссылка на объект, который станет прототипом; дефолт = {constructor: Func})
				/*Если prototype у конструктора не было изменено, то мы сможем получать констуктор объекта через св-во constructor

				Func.prototype = obj 		-задать прототип создаваемым ф-циям

				/*Все методы объектов и примитивов хранятся в их прототипах Number.prototype, Array.prototype ... (все наследуются от Object.prototype)



				Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
				Object.getPrototypeOf(obj) 			– возвращает свойство [[Prototype]] объекта obj.
				Object.setPrototypeOf(obj, proto) 	– устанавливает свойство [[Prototype]] объекта obj как proto.

				Object.create(null) 				- создание объекта без прототипов(__proto__ -как обычное св-во)

		1)Массивы:
			/*В Массиве могут храниться элементы любого типа
			/*Быстрее работает с упорядоченными данными

			1)Создание/Удаление
				/*Является объектом поэтому 
				/*!имя Массива! = !имя Массива! 	-копируется ссылка, а не создается новый Массив

				let !имя массива! 		= [!зн-я!]		
				let !имя массива! 		= new Array(!зн-я!) -инициализация				/*если указано одно число то создастся пустой с этой длинной
				let !имя массива! 		= []	
				let !имя массива! 		= new Array() 		-создание пустых Массивов

				let !имя массива! = arr.slice() 	-создание копии arr

				!имя массива!.length = 0 			-удаление массива

			2)Элементы:

				!имя массива![!индекс!]						-взятие значения в ячейке
				!имя массива![!индекс!] = !значение!		-смена значения в ячейке(или добавление)

				for( of ) 									-цикл для элементов Массива

				delete !имя массива![!индекс!] 				-удаление элемента(без сдвига)

		2)Строки:
			/*нельзя изменять

			1)Создание
				!имя строки! = '...'
				!имя строки! = "..."
				!имя строки! = `...${!значение!}...` -строка со значением переведенным в строку /*возможен перенос строки

			2)Символы:
				!стр![!инд!]			-взятие одного символа строки /* !стр!.charAt(!инд!) -всегда вернет строку
				for( of ) 				-цикл для символов строк

			3)Регулярные выражения:

				1)Создание
					new RegExp(!pattern!, !flags!) 		
					/!pattern!/!flags! 					-возвращает регулярное выражение

				2)Флаги

					i 	-поиск не зависит от регистра
					g 	-поиск ищет все совпадения, без него – только первое.
					m 	-многострочный режим
					s 	-включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n
					u 	-включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар
					y 	-режим поиска на конкретной позиции в тексте

				3)Методы

					!str!
						.match(regexp) 					-возвращает массив совпадений(без g - массив с одним значением) либо null.
							.index
							.input
						.replace(regexp, replacement) 	-заменяет совпадения

					replacement
						$&		-вставляет всё найденное совпадение
						$`	 	-вставляет часть строки до совпадения
						$'		-вставляет часть строки после совпадения
						$n		-если n это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения
						$<name>	-вставляет содержимое скобочной группы с именем name
						$$		-вставляет символ "$"



					!regexp!
						.test(str) 				-если есть совпадение вернет true иначе false

				4)Символьные классы:

					\d 	– цифры.
					\D 	– не цифры.
					\s 	– пробельные символы, табы, новые строки.
					\S 	– все, кроме \s.
					\w 	– латиница, цифры, подчёркивание '_'.
					\W 	– все, кроме \w.
					. 	– любой символ, если с флагом регулярного выражения s, в противном случае любой символ, кроме перевода строки \n.

	8)Методы и св-ва:

		1)Массив

			1)ВОЗВРАЩЕНИЕ НА ОСНОВЕ МАССИВА

				.length					-возвращает длину(можно переназначать для удаления или добавления)


				.map(func(item, index, array))	 				-вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции				
				.reduce(func(prevVal, item, ind, arr), init)	-проходиться по всем эл-там, возвращенное значение передается в первый аргумент для следующего эл-та
				.reduceRight 									-работает аналогично, но проходит по массиву справа налево
				.filter(func(item, index, array)				-проходиться по всем элементам, если ф-ция возвращает true данный элемент добавляется в Массив который вернется(иначе [])

				.splice(!инд!,!к-во!,[!зн-я!])	-возвращает часть удаленного Массива и изменяет вставляя новые
												значение первого аргумента может быть отрицательным, тогда позиция определяется с конца
				.slice(start, end) 				-возвращает часть Массива от start до (не включая) end.
												end может быть пустым, тогда он рассматривается как бесконечность.
												значение первого аргумента может быть отрицательным, тогда позиция определяется с конца

				.concat(arg1, arg2...) 			-добавляет элементы к Массиву из аргументов и возвращает(массивы и значения, объекты если есть св-во)

				Array.isArray(value)								-возвращает true, если value массив, и false, если нет
				Array.from(obj[, mapFn, thisArg]) 					-возвращает Массив создавая его из итерируемого объекта или псевдомассива
				


			2)ДЛЯ ДОБАВЛЕНИЯ/УДАЛЕНИЯ ЭЛЕМЕНТОВ

				.push(!значения!)		-добавление в конец элемента	
				.pop()					-удаление последнего элемента и его возвращение
				.shift()				-сдвиг влево(удаление первого элемента и его возвращение)	/*медленный
				.unshift(!значения!)	-сдвиг вправо(добавление первого элемента) 					/*медленный

				.splice(!инд!,!к-во!,[!зн-я!])	-возвращает часть удаленного Массива и изменяет вставляя новые
												значение первого аргумента может быть отрицательным, тогда позиция определяется с конца
												значение первого аргумента может быть отрицательным, тогда позиция определяется с конца
				.concat(arg1, arg2...) 			-добавляет элементы к Массиву из аргументов и возвращает(массивы и значения, объекты если есть св-во)



			3)ДЛЯ ПОИСКА СРЕДИ ЭЛЕМЕНТОВ

				.lastIndexOf(item, pos)
				.indexOf(item, pos)				-он ищет item, начиная с позиции pos возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений
				.includes(item, pos) 			-возвращает true, если есть item, либо false, если нет.

				.find(func(item, index, array)) 			-проходиться по всем элементам, если ф-ция возвращает true возвращается данный элемент(иначе undefined)
				.findIndex(func(item, index, array))		-проходиться по всем элементам, если ф-ция возвращает true возвращается индекс данного элемента(иначе -1)
				

			
			4)ДЛЯ ПРЕОБРАЗОВАНИЯ МАССИВА

				.forEach(func(item, index, array)) 			-позволяет запускать функцию для каждого элемента массива

				.sort(func)									-сортирует массив по возвращаемому значению(без ф-ции строчное сравнение)
				/* arr.sort((a,b)=>a-b) 					-числовое сравнение

				.reverse() 					-меняет порядок элементов на обратный

				.join(glue) 				-возвращает строку из элементов, вставляя glue между ними

		2)Строка

			1)ВОЗВРАЩЕНИЕ НА ОСНОВЕ СТРОКИ

				.length					-возвращает длину

				.slice(start, end) 		-возвращает часть строки от start до (не включая) end.
										end может быть пустым, тогда он рассматривается как бесконечность.
										значение первого аргумента может быть отрицательным, тогда позиция определяется с конца
				.substring(start, end)	-возвращает часть строки между start и end
				.substr(start, length) 	-возвращает часть строки от start длины length
										значение первого аргумента может быть отрицательным, тогда позиция определяется с конца
				.trim() 				-возвращает строку без пробелов, переносов и тд(невидимых символов)

				.repeat(n) 				-повторяет строку n раз
				.charAt(!инд!) 			-всегда вернет строку

				.toUpperCase()			-возвращает строку с заглавными буквами
				.toLowerCase()			-возвращает строку с маленькими буквами

				.codePointAt(pos)			-возвращает код для символа, находящегося на позиции pos
				String.fromCodePoint(code) 	-создаёт символ по его коду code

				.split(delim) 				-разбивает строку на массив и возвращает его по заданному разделителю delim(без делим разбиение побуквенно)


			2)ДЛЯ ПОИСКА СРЕДИ СИМВОЛОВ

				.lastIndexOf(substr, pos)
				.indexOf(substr, pos)	-он ищет подстроку substr, начиная с позиции pos
										возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений
				.includes(substr, pos) 	-возвращает true, еслиесть подстрока substr, либо false, если нет.

				.startsWith() 
				.endsWith() 			-проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой

		3)Число

			.toFixed(!зн!) 			-округляет число до n знаков после запятой и возвращает строковое представление результата
			.toString(!зн!) 		-строковое представление с основанием

			.isNaN(!зн!) 			-преобразует значение в число и проверяет является ли оно NaN
			.isFinite(!зн!) 		-преобразует аргумент в число и возвращает true, если оно является обычным числом(не NaN/Infinity/-Infinity) 

		
		4)Объект:

			1)ВОЗВРАЩЕНИЕ НА ОСНОВЕ ОБЪЕКТА

				.hasOwnProperty(key)				-возвращает true, если у obj есть свойство с именем key(собс)

				Object.keys(obj) 					–возвращает массив ключей(собс)
				Object.values(obj) 					–возвращает массив значений(собс)
				Object.entries(obj)					–возвращает массив пар [ключ, значение](собс)
				/*игнорируют символьные ключи

				Object.getOwnPropertySymbols(obj)	-возвращает массив только символьных ключей(собс)
				Object.getOwnPropertyNames(obj) 	–возвращает массив всех строковых ключей(собс)
				Reflect.ownKeys(obj) 				-возвращает все ключи(собс)

				Object.getOwnPropertyDescriptor(obj, propertyName) 			-полная информация о св-ве, возвращает дескриптор(объект с 4-мя св-вами-атрибутами)
				Object.getOwnPropertyDescriptors(obj) 						-возвращает объект, содержащий все собственные дескрипторы свойств объекта.


			Object.defineProperty(obj, propertyName, descriptor) 		-изменить флаги(по дефолту все флаги false)
			Object.defineProperties(obj, { 								-определяет мн-во св-в для объекта сразу
			  prop1: descriptor1,
			  prop2: descriptor2,
			  ...
			})


			Object.fromEntries(arr)				- получив массив пар вида [ключ, значение], он создаёт из них объект

			Object.assign(obj1, obj2, ...) 								-в первый объект копируются все св-ва остальных(даже символьные)

			Object.freeze(obj) 					-предотвращает добавление, удаление и изменение свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости у объекта и возвращает его же
			/*Заморозка не глубокая

		5)Map:

			.set(key, value) 	– записывает по ключу key значение value(возвращает новый Map)
			.get(key) 			– возвращает значение по ключу или undefined, если ключ key отсутствует.
			.has(key) 			– возвращает true, если ключ key присутствует в коллекции, иначе false.
			.delete(key) 		– удаляет элемент по ключу key.
			.clear() 			– очищает коллекцию от всех элементов.
			.size 				– возвращает текущее количество элементов.

			.forEach(func(value, key, map)) 		-выполняет ф-цию для каждой пары ключ-значение

			.keys() 			– возвращает итерируемый объект по ключам
			.values() 			– возвращает итерируемый объект по значениям
			.entries() 			– возвращает итерируемый объект по парам вида [ключ, значение](массив со массивами), этот вариант используется по умолчанию в for..of

		6)Set:

			.add(value) 		– добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект.
			.delete(value) 		– удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
			.has(value) 		– возвращает true, если значение присутствует в множестве, иначе false.
			.clear() 		– удаляет все имеющиеся значения.
			.size 			– возвращает количество элементов в множестве

			.forEach(func(value, valueAgain, set)) 		-выполняет ф-цию для каждого значения

			.values() 	– возвращает перебираемый объект для значений,
			.keys()		– возвращает перебираемый объект для значений,
			.entries() 	– возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map
   
		7)Date:

			Date.now() 			-возвращает текущий таймстамп
			Date.parse(str) 	-считывает дату из строки и возвращает таймстамп(формат строки: YYYY-MM-DDTHH:mm:ss.sssZ)


			/*ПОЛУЧЕНИЕ ВРЕМЕНИ В СООТВЕТСТВИИ С МЕСТНЫМ ЧАСОВЫМ ПОЯСОМ(имеются UTC варианты)
			.getFullYear()		-получить год (4 цифры)
			.getMonth()			-получить месяц, от 0 до 11.
			.getDate()			-получить день месяца, от 1 до 31

			.getHours() 		-получить часы
			.getMinutes()		-получить минуты
			.getSeconds() 		-получить секунды
			.getMilliseconds() 	-получить миллисекунды

			.getDay() 			-получить определённый день недели(0-воск)


			.getTime() 				-для заданной даты возвращает таймстамп
			.getTimezoneOffset()	-возвращает разницу в минутах между местным часовым поясом и UTC


			/*УСТАНОВКА КОМПОНЕНТОВ ДАТЫ
			.setFullYear(year, [month], [date])
			.setMonth(month, [date])
			.setDate(date)
			.setHours(hour, [min], [sec], [ms])
			.setMinutes(min, [sec], [ms])
			.setSeconds(sec, [ms])
			.setMilliseconds(ms)
			.setTime(milliseconds) 				-устанавливает дату таймстампом
			/*Могут быть отрицательные и 0

		8)Function:

			.call(obj, arg1, arg2, ...) 	-вызывает ф-цию с this=obj(если для метода переназначена ссылка obj->this)
			.apply(obj, args) 				-вызывает ф-цию с this=obj и псевдомассивом с аргументами

			.bind(obj [,arg1,arg2,...]) 	-возвращает «привязанный вариант» функции func, фиксируя контекст this и первые аргументы arg1, arg2…, если они заданы.


		9)Промисы:

			Promise.all(promises) – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.

			Promise.allSettled(promises) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
			state: "fulfilled", если выполнен успешно или "rejected", если ошибка,
			value – результат, если успешно или reason – ошибка, если нет.

			Promise.race(promises) – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.
			Promise.resolve(value) – возвращает успешно выполнившийся промис с результатом value.
			Promise.reject(error) – возвращает промис с ошибкой error.

		10)Бинарные данные:
			/*ArrayBuffer/TypedArray/DataView/TextEncoder/TextDecoder/Blob/File/FileReader
			/*TypedArray - мн-во конструкторов для разных типов представления данных буфера

			ArrayBuffer:
				.byteLength 				-размер содержимого ArrayBuffer в байтах.

			TypedArray:
				/*Все методы из массива кроме: .concat, .splice

				(TypedArray).BYTES_PER_ELEMENT 	-кол-во байт на каждое число

				.byteLength 				-размер содержимого ArrayBuffer в байтах.

				.length 					-кол-во чисел в буфере
				.buffer 					-ссылка на объект ArrayBuffer

				.set(fromArr, [offset]) 	-копирует все элементы из fromArr в TypedArray, начиная с позиции offset (0 по умолчанию).
				.subarray([begin, end]) 	-создаёт новое представление того же типа для данных, начиная с позиции begin до end (не включая).
				/*Это похоже на метод slice (который также поддерживается), но при этом ничего не копируется – просто создаётся новое представление, чтобы совершать какие-то операции над указанными данными

			DataView:
				.get...(pos) 				-доступ к данным нужного типа 	


			TextDecoder:
				.decode([input], [options]) 		-метод для декодирования(input – бинарный буфер,options- настройки)
			TextEncoder:
				.encode(str) 						– возвращает бинарный массив Uint8Array, содержащий закодированную строку.
				.encodeInto(str, destination) 		– кодирует строку (str) и помещает её в destination, который должен быть экземпляром Uint8Array.



			Blob:
				.slice([byteStart], [byteEnd], [contentType]) 	-возвращает срез Blob


			File:
				.name 											– имя файла,
				.lastModified 									– таймстамп для даты последнего изменения.

			FileReader:
				.readAsArrayBuffer(blob) 			– считать данные как ArrayBuffer
				.readAsText(blob, [encoding]) 		– считать данные как строку (кодировка по умолчанию: utf-8)
				.readAsDataURL(blob) 				– считать данные как base64-кодированный URL.
				.abort() 							– отменить операцию.

				/*Свойства получаемые после чтения
				.result 							-результат чтения (если оно успешно)
				.error 								-объект ошибки (при неудаче).


		11)Response:
			.status 		– код статуса HTTP-запроса
			.ok 			– логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.\
			.headers 		- заголовки ответа(похож на Map - имеет такие же методы)

			.text() 			– читает ответ и возвращает как обычный текст,
			.json() 			– декодирует ответ в формате JSON,
			.formData() 		– возвращает ответ как объект FormData (разберём его в следующей главе),
			.blob() 			– возвращает объект как Blob (бинарные данные с типом),
			.arrayBuffer() 		– возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
			.body 				– это объект ReadableStream, с помощью которого можно считывать тело запроса по частям.

		12)FormData:
			.append(name, value) 			– добавляет к объекту поле с именем name и значением value,
			.append(name, blob, fileName) 	– добавляет поле, как будто в форме имеется элемент <input type="file">, третий аргумент fileName устанавливает имя файла (не имя поля формы), как будто это имя из файловой системы пользователя,
			.delete(name) 					– удаляет поле с заданным именем name,
			.get(name) 						– получает значение поля с именем name,
			.has(name) 						– если существует поле с именем name, то возвращает true, иначе false

			.set(name, value)
			.set(name, blob, fileName) 		- аналогично append но удаляет все уже имеющиеся поля с именем name


	9)Работа в браузере

		/*Вся HTML страница является объектом с другими объектами внутри
		/*ТЕГ в HTML это объект для JS
		

		alert(..)							-выводит на сайт сообщение
		prompt(text,value)					-ввод из сайта в JS
		setTimeout(!ф-ция!, !мс!) 			-выполнение ф-ции через время



		1)Взаимодействие с DOM объектами


			1)Возвращение элементов
				/* .getElementsBy - возвращают живые коллекции

				document							-глобальный объект для управления сайтом

					.documentElement 				-возвращает объект html
					.head 							-возвращает объект head
					.body 		 					-возвращает объект body
						
					.table							-таблица
						.rows 						-коллекция tr
							.cells 					-коллекция td

					.getElementById("!id!")			-возвращает объект по id
					.getElementsByName(name) 		-возвращает элементы с заданным атрибутом name.

					.elementFromPoint(clientX, clientY) 		-возвращает наиболее глубоко вложенный элемент по заданным координатам окна(или null)

					.activeElement 					-текущий элемент с фокусом


				(elem)

					.querySelector("!css!") 	-возвращает первый элемент внутри по CSS-селектору.
					.querySelectorAll("!css!") 	-возвращает псевдомассив из элементов внутри по CSS-селектору.

					.closest("!css!") 			-возвращает ближайшего предка(или себя), который соответствует CSS-селектору 	
					.matches("!css!")			-возвращает bool в зависимости от совпадения CSS-селектора

					
					.getElementsByTagName(tag) 			-ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.
					.getElementsByClassName(className) 	-возвращает элементы, которые имеют данный CSS-класс.

					parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling 		 						-для всех узлов
					parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling 	-только для узлов-элементов

					.elementFromPoint(x, y) 		- возвращает самый глубоко вложенный элемент в окне, находящийся по координатам

			2)Создание/вставка/удаление элементов

				document

					.createElement(tag) 	– создаёт элемент с заданным тегом
					.createTextNode(value) 	– создаёт текстовый узел (редко используется)

				(elem)
				
					.cloneNode(deep)  		– клонирует элемент, если deep==true, то со всеми дочерними элементами.

					.append(...nodes or strings) 		– вставляет в node в конец
					.prepend(...nodes or strings)		– вставляет в node в начало,
					.before(...nodes or strings) 		– вставляет прямо перед node,
					.after(...nodes or strings) 		– вставляет сразу после node,
					.replaceWith(...nodes or strings) 	– заменяет node.
					.remove() 							– удаляет node.

					.insertAdjacentHTML(where, html) 	- вставляет фрагмент HTML в зависимости от where("beforebegin", "afterbegin", "beforeend", "afterend")

			3)Работа с элементами

				.nodeType 			-позволяет узнать тип DOM-узла(1-элемент,3-текст)(только для чтения)
				.nodeName 		 	-возвращает название тега. Для узлов-неэлементов описывает, что это за узел.
				.tagName 			-возвращает название тега.

				.innerText 	
				.innerHTML 			-внутреннее HTML-содержимое узла-элемента. Можно изменять.
				.outerHTML 			-полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.

				.nodeValue/data 	-содержимое узла-неэлемента (текст, комментарий). Можно изменять.
				.textContent 		-текст внутри элемента: HTML за вычетом всех <тегов>. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст.

				.hidden 				-когда значение установлено в true, делает то же самое, что и CSS display:none.

				.contains()

			4)Стили:

				(elem)

					.className 		– строковое значение св-ва class(для всего набора). Можно изменять
					.classList 		– объект со всеми классами элемента и методами(для отдельных)
						.add("cls")	 			- добавить класс	
						.remove("cls")	 		- удалить класс
						.toggle("cls")	  		- добавить класс, если его нет, иначе удалить.
						.contains("cls")	  	- проверка наличия класса, возвращает bool

					.style 			 					- объект со стилями, соответствует тому что в атрибуте style(св-ва объекта в camelCase = св-ва стилей)
						.cssText 						- перезапись всей строке стилей

				getComputedStyle(elem, [pseudo])  	- функция возвращает объект для чтения окончательных стилей(только чтение)

			5)Геометрия элементов:
				
				1)Св-ва элементов
					/*Все доступно только для чтения кроме scrollLeft/scrollTop

					.offsetParent 						– ближайший CSS-позиционированный родитель или ближайший td, th, table, body.
					.offsetLeft/offsetTop 				– позиция в пикселях верхнего левого угла относительно offsetParent.
					.offsetWidth/offsetHeight 			– «внешняя» ширина/высота элемента, включая рамки.

					.clientLeft/clientTop 				– расстояние от верхнего левого внешнего угла до внутренного. В основном = ширинам левой/верхней рамки.
					.clientWidth/clientHeight 			– ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки.

					.scrollWidth/scrollHeight 			– ширины/высота содержимого, аналогично clientWidth/Height, но учитывают прокрученную, невидимую область элемента.
					.scrollLeft/scrollTop 				– ширина/высота прокрученной части элемента, считается от верхнего левого угла.


					
					document.documentElement.clientWidth/Height 	-ширина/высота видимой части документа(окна)
					Math.max(
					  document.body.scrollHeight, document.documentElement.scrollHeight,
	 				  document.body.offsetHeight, document.documentElement.offsetHeight,
					  document.body.clientHeight, document.documentElement.clientHeight
					); 												-ширина/высота всего документа с прокрученной частью

				2)Прокрутка

					window.pageYOffset/pageXOffset 		- текущая прокрутка окна(как .scrollLeft/scrollTop но работает везде и только для чтения)
					window.scrollTo(pageX,pageY) 		– изменить текущую прокрутку(абсолютные координаты)
					window.scrollBy(x,y) 				– изменить текущую прокрутку(прокрутка относительно текущего места)
					(elem).scrollIntoView(top) 			– выровнять относительно верхней/нижней части окна

					(elem).style.overflow = "hidden" 	- остановка прокрутки элемента
					(elem).style.overflow = "" 			- возобновление прокрутки элемента

				3)Координаты
					/*Координаты относительно документа: (elem).getBoundingClientRect().top/left+ window.pageYOffset/pageXOffset

					(elem)
						.getBoundingClientRect()		- возвращает объект с координатами элемента относительно окна в св-вах(класса DOMRect)
							.x/y 								– X/Y-координаты начала прямоугольника относительно окна,
							.width/height 						– ширина/высота прямоугольника (могут быть отрицательными).

							.top/bottom 							– Y-координата верхней/нижней границы прямоугольника,
							.left/right 							– X-координата левой/правой границы прямоугольника.

						.elementFromPoint(x, y) 		- возвращает самый глубоко вложенный элемент в окне, находящийся по координатам

		2)Атрибуты и св-ва

			/* Свойства(Тип: любой, Имя: регистрозависимо)
			/* Атрибуты(Тип: строка, Имя: регистронезависимо)
			/* Для стандартных HTML атрибутов создаются соответствующие св-ва

			Методы для работы с атрибутами:
				.hasAttribute(name) 		– проверить на наличие.
				.getAttribute(name) 		– получить значение.
				.setAttribute(name, value) 	– установить значение.
				.removeAttribute(name) 		– удалить атрибут.
				.attributes 				– это коллекция всех атрибутов(объекты со св-вами name, value)

			dataset:
				.dataset 		-св-во объект, в котором хранятся все атрибуты data-* (*-новое св-во)

		3)События:
			/*Способы назначения обработчиков событий: атрибут/св-во/спец методы
			/*В таких обработчиках this=(elem)
			/*При событии сначала идет погружение до элемента а потом всплытие(вызовы обработчиков)
			/*Алгоритм делегирования:
			/*	1.Вешаем обработчик на контейнер.
			/*	2.В обработчике проверяем исходный элемент event.target.
			/*	3.Если событие произошло внутри нужного нам элемента, то обрабатываем его.


			1)Создание обработчика/события
				(elem)
					(Attribute) ="!тело ф-ции-обработчика!" 		-создание обработчика события через атрибут в HTML(Attribute - click, contextmenu, mouseover...)
					.(ONeventProp) = func 							-создание обработчика события через св-во(только 1)
					.addEventListener(event, handler[, phase])		-создание обработчика события через спец методы(множество)
					.removeEventListener(event, handler[, options])	-удаление обработчика события через спец методы
						handler 										-ссылка на ф-цию или на объект с методом handleEvent
						event 											-имя-строка события(click, contextmenu, mouseover/mouseout, mousedown/mouseup, mousemove, keydown/keyup...)
						phase 											-если true то обработчик сработает на погружении

				Event(name, options) 						-конструктор создания события
					name 									-имя-строка события
					options 								-объект
						bubbles									-true - всплытие работает
						cancelable 							 	-true - отмена с помощью .preventDefault() работает
				(elem).dispatchEvent(event) 				-запуск события

			2)Работа с событиями

				(event)									-при событии создается объект события и передается в качестве аргумента в обработчик
					.type 									-тип события

					.target 								-самый глубоко вложенный элемент, на котором произошло событие
					.currentTarget 							-элемент, на котором сработал обработчик(почти this)
					
					.eventPhase 							–на какой фазе сработал обработчик


					.stopPropagation() 						-остановка всплытия
					.preventDefault() 						-отмена действия браузера по умолчанию(return false - для обработчика)

					.defaultPrevented 						-true если действие браузера пр умолчанию предотвращено 

			3)События мыши/указателя

				(event)
					.which 						-номер кнопки мыши(mousedown/mouseup)

					.altKey 					-true - нажат alt
					.ctrlKey 					-true - нажат ctrl 
					.shiftKey 					-true - нажат shift
					.metaKey 					-true - нажат cmd(MAC)

					.clientX/clientY 			-координаты относительно окна
					.pageX/pageY 				-координаты относительно документа

					.relatedTarget  			-содержит ссылку на элемент, с/на который мы переходим(mouseover/mouseout, mouseenter/leave)


					.pointerId 						– уникальный идентификатор указателя, вызвавшего событие
					.isPrimary 						– true для основного указателя(первое касание)

				(elem)
					.setPointerCapture(pointerId) 		– привязывает события с данным pointerId к elem(меняет target)
					.releasePointerCapture(pointerId)	- отменяет привязку(автоматически при pointerup, pointercancel, удалении elem)

			4)События клавиатуры

				(event)
					.code 						-возвращает строку-код, привязанный к физическому расположению клавиши на клавиатуре
					.key 						-возвращает строку-символ(зависит от раскладки)

			5)Остальное:

				1)Событие фокуса
					/*порядок фокуса через ТАБ: 
					/*1-...
					/*0 и элементы с возможным фокусом по порядку в документе
					/*-1 - никогда(задаются только через методы)

					(elem)
						.focus() 		-метод устанавливающий фокус на элементе
						.blur() 		-метод снимающий фокус на элементе

					document.activeElement 	-текущий элемент с фокусом

					tabindex 			-атрибут в HTML, который позволяет переключать фокусы через ТАБ в нужной последовательности(подходит для элементов без возможности фокуса)

				2)Событие отправки формы

					(form)
						.submit() 		-метод который отправит форму на сервер вручную без вызова submit

				3)Событие законченной анимации(transitionend)

					(event)
						.propertyName 		-имя свойства, анимация которого завершилась
						.elapsedTime 		-время (в секундах), которое заняла анимация, без учёта transition-delay.

		4)Формы/Элементы управления
			/*события: фокуса, изменения, копия/вставка

			1)Св-ва формы

				document
					.forms 				-коллекция всех форм(выбор через name/index)

				(form) 					-форма в документе, является также коллкцией всех элементов в форме(выбор через name/index)
					.elements 			-коллекция всех элементов в форме(выбор через name/index)

				(elem) 					-элемент в форме
					.form 				-ссылка на свою форму

				<select>
					.value 				-значение выбранного в данный момент option
					.selectedIndex 		–номер выбранного <option>
					.options 			–коллекция из подэлементов <option>

				<option>
					.selected 			-bool выбрана ли опция
					.index 				-номер опции среди других в списке <select>
					.text 				-содержимое опции(текст)

				Option(text, value, defaultSelected, selected) 			-конструктор для создания элемента <option>

				<input>
					.value 				-строка-текст внутри
					.checked 			-bool для чекбокса

				<textarea> 
					.value 				-строка-текст внутри

		5)Подготовка документа:
			/*события: DOMContentLoaded, load, beforeunload, unload, readystatechange

			navigator.sendBeacon(url, data) 	-посылает данные в фоне
			document.readyState 				-показывает нам текущее состояние загрузки

			async 								-аттрибут <script>, запуск скрипта - загрузка скрипта(динамически загружаемые скрипты стоят сразу с async=true, можно изменить)
			defer 								-аттрибут <script>, запуск скрипта - после загрузки документа(порядок-как расположены в документе, только для внешних скриптов + у type="module" стоит автоматом)
												-обычный <script> препятствует дальнейшей загрузке документа


		6)Сервер/Работа с данными:

			1)Асинхронность
				/*Код ниже загружаемых данных не ждет, а выполняется сразу. Поэтому чтобы работать с этими данными нужны колбэки и промисы

				1)Колбэки
					/*Используем событие load для выполнения колбэка
					/*Минус в том что может образоваться адская пирамида вызовов

					Пример:

						function loadScript(src, callback) {
						  let script = document.createElement('script');
						  script.src = src;

						  script.onload = () => callback(script);

						  document.head.append(script);
						}

				2)Промисы
					/*Используем объект promise
					/*внутр св-ва promise зависящие от вызываемого колбэка (resolve, reject):
					/*state  = "pending" -> "fulfilled" или "rejected"
					/*result = undefined -> value или error 	
					/*методы then/catch/finally(handler) возвращают promise, все они помещаются в микрозадачи


					Promise(function(resolve, reject) { ... }) 		-конструктор создания промиса(ф-ция внутри запускается сразу после создания)
						resolve(value) 									—вызываемый колбэк если работа завершилась успешно, с результатом value(ф-ция в JS)
						reject(error) 									—вызываемый колбэк если произошла ошибка, error – объект ошибки(ф-ция в JS)


					.then( 											-метод promise, который выполняет действие когда state != "pending"
	 					function(result) { ... }, 						-обработает успешное выполнение
						function(error)  { ... } 						-обработает ошибку(можно не прописывать)
					);

					.catch(errorHandlingFunction) 					-метод promise, который выполняет действие когда state = "rejected"(.then(null, f))
					.finally(HandlingFunction) 						-метод promise, который выполняет действие когда state != "pending" в любом случае(.then(f, f))

					Пример:

						function loadScript(src) {
						  return new Promise(function(resolve, reject) {
						    let script = document.createElement('script');
						    script.src = src;

						    script.onload = () => resolve(script);
						    script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));

						    document.head.append(script);
						  });
						}

						let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

						promise.then(
						  script => alert(`${script.src} загружен!`),
						  error => alert(`Ошибка: ${error.message}`)
						);

						promise.then(script => alert('Ещё один обработчик...'));

					Методы Promise:

						Promise.all(promises) – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.
						Promise.allSettled(promises) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
						state: "fulfilled", если выполнен успешно или "rejected", если ошибка,
						value – результат, если успешно или reason – ошибка, если нет.
						Promise.race(promises) – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.
						Promise.resolve(value) – возвращает успешно выполнившийся промис с результатом value.
						Promise.reject(error) – возвращает промис с ошибкой error.

				3)async/await
					/* async 	-ставится только перед ф-циями 
					/* await 	-ставится только в ф-циях с async

						async !func! 	-такая ф-ция всегда возвращает промис(другие типы просто оборачиваются в промис)
						await !promis! 	-async ф-ция будет ждать выполнения промиса справа и только после продолжит выполняться
						(если промис завершился с ошибкой await выбросит ее и async будет возвращать промис в состоянии rejected)

				4)Прерывание асинхронной задачи:

					new AbortController() 		-создание контроллера
						.signal 					-объект на котором может отслеживаться событие abort 
							.aborted 					-булево значение - произошла ли отмена
						.abort()					-генерируется событие с именем abort на объекте controller.signal, свойство controller.signal.aborted становится равным true.


					let promis = new Promise((resolve, reject) => {  			-пример для прерывания промиса		
					  ...
					  controller.signal.addEventListener('abort', reject);
					});
					
				5)Алгоритм выполнения:

					-Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
					-Исполнить все микрозадачи:
						Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
					-Отрисовать изменения страницы, если они есть.
					-Если очередь макрозадач пуста – подождать, пока появится макрозадача.
					-Перейти к шагу 1.

					Схема:
						МАКРО задача
							МИКРО задачи
							РЕНДЕР
						МАКРО задача
							МИКРО задачи
							РЕНДЕР
						...

					Макро задачи:
						script
						setTimeout/setInterval (c 0 задержкой - задержка: добавление макрозадачи через)
					Микро задачи:
						.then/catch/finally
						queueMicrotask()

			2)Сетевые запросы

				1)fetch

					1)Основное

						/*Без method отправляет GET запрос
						fetch(url, [options]) 		-ф-ция для запроса на сервер, возвращает промис(url – URL для отправки запроса, options – дополнительные параметры)

						/*1 этап
						/*-получаем объект типа Response
							.status 		– код статуса HTTP-запроса
							.ok 			– логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.\
							.headers 		- заголовки ответа(похож на Map - имеет такие же методы)

							.text() 			– читает ответ и возвращает как обычный текст,
							.json() 			– декодирует ответ в формате JSON,
							.formData() 		– возвращает ответ как объект FormData (разберём его в следующей главе),
							.blob() 			– возвращает объект как Blob (бинарные данные с типом),
							.arrayBuffer() 		– возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),

							.body 				– это объект ReadableStream, с помощью которого можно считывать тело запроса по частям
							/*Нужен для отслеживания процесса получения данных. Нет способа отслеживать процесс отправки данных(для этого используется XMLHttpRequest)

						/*2 этап
						/*-получаем тело ответа(получить можно только один раз)




						fetch(url, options) 								-шаблон
						  .then(response => response.json()) 					-1 этап
						  .then(result => /* обрабатываем результат */) 		-2 этап


						options{
							headers: {						-установка заголовка запроса
								"Content-Type": 				-тип контента
							}
							method: 		– HTTP метод
							body: 			– тело запроса(строка(JSON обычно), объект FormData для отправки данных как form/multipart, Blob/BufferSource для отправки бинарных данных)

							signal: 		- помещаем объект на котором может отслеживаться событие abort(нужен для прерывания запроса)
							credentials: "include" 	-запрос с авторизационными данными(придут и куки)
						}

					2)Запросы с помощью fetch:

						GET:
							fetch(url)
						POST:
							fetch(url, {
								method: "POST",
								body: ...
							}) 

					3)Ход загрузки:
						response.body.getReader()
							.read()
								.done
								.value

					4)Прерывание запроса
						/*fetch сам слушает abort если задать signal
						/*Когда fetch отменяется, его промис завершается с ошибкой AbortError
						/*Если задать controller.signal нескольким fetch то controller.abort() остановит их всех

						let controller = new AbortController();
						fetch(url, {
						  signal: controller.signal
						}); 									-создание контролируемого fetch

						controller.abort(); 					-вызов останавливающий fetch

				2)XMLHttpRequest:
					.
					.


				3)FormData
					/*append позволяет добавлять поля с одинаковыми name
					/*поля можно перебирать с помощью for of, но нельзя прочитать другими способоми
					new FormData([form]) 		-создание объекта представляющий данные HTML формы(form - элемент HTML-формы <form> - объект автоматически прочитает из нее поля)
						.append(name, value) 			– добавляет к объекту поле с именем name и значением value,
						.append(name, blob, fileName) 	– добавляет поле, как будто в форме имеется элемент <input type="file">, третий аргумент fileName устанавливает имя файла (не имя поля формы), как будто это имя из файловой системы пользователя,
						.delete(name) 					– удаляет поле с заданным именем name,
						.get(name) 						– получает значение поля с именем name,
						.has(name) 						– если существует поле с именем name, то возвращает true, иначе false

						.set(name, value)
						.set(name, blob, fileName) 		- аналогично append но удаляет все уже имеющиеся поля с именем name

					for(let [name, value] of formData) {	-перебор полей
						...
					}

				4)URL:

					new URL(url, [base]) 	-создания объекта для управления url строкой
					(url – полный URL-адрес или только путь, base –  если указан и аргумент url содержит только путь, то адрес будет создан относительно него)
						.href
						.origin
						.host
						.protocol
						.hostname
						.port
						.pathname
						.search
						.hash 					-разбиение url адреса

						.searchParams 			– объект типа URLSearchParams(яляется перебираемым, аналогично Map)
							.append(name, value) 	– добавить параметр по имени,
							.delete(name) 			– удалить параметр по имени,
							.get(name) 				– получить параметр по имени,
							.getAll(name) 			– получить все параметры с одинаковым именем name (такое возможно, например: ?user=John&user=Pete),
							.has(name) 				– проверить наличие параметра по имени,
							.set(name, value)		– задать/заменить параметр,
							.sort() 				– отсортировать параметры по имени, используется редко

			3)Хранение данных в браузере:

				1)Куки
					/*имя и значение куки должны быть закодированы.
					/*одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).

					document.cookie  					-вернет строку с куки данными(ключ=значение;...)
					document.cookie = "!key!=!val!" 	-запись в куки(обновит только упомянутые в ней куки, остальные не трогает)

					Настройки куки(указываются после записи ключа):

						path=/ 				 	-по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
						domain=site.com 		-по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
						expires/max-age  		-устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера(отрицательное значение удалит куки)
						secure 					-делает куки доступным только при использовании HTTPS.
						samesite  				-запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.

				2)Объекты веб-хранилища:
					/*sessionStorage:
					/* -Разделяется в рамках вкладки браузера, среди ифреймов из того же источника
					/* -«Переживает» перезагрузку страницы (но не закрытие вкладки)
					/*localStorage:
					/* -Совместно используется между всеми вкладками и окнами с одинаковым источником	
					/* -«Переживает» перезапуск браузера	

					/*key и value должны быть строками.
					/*Данные привязаны к источнику (домен/протокол/порт).


					localStorage(sessionStorage)
						.setItem(key, value) 		– сохранить пару ключ/значение.
						.getItem(key) 				– получить данные по ключу key.
						.removeItem(key) 			– удалить значение по ключу key.
						.clear() 					– удалить всё.
						.key(index) 				– получить ключ на заданной позиции.
						.length 					– количество элементов в хранилище.

					Cобытие storage(можно настроить обработчики событий) 
						/*происходит для объекта при вызове setItem, removeItem, clear на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано
						(event)
							.key 			– ключ, который обновился (null, если вызван .clear()).
							.oldValue 		– старое значение (null, если ключ добавлен впервые).
							.newValue		– новое значение (null, если ключ был удалён).
							.url 			– url документа, где произошло обновление.
							.storageArea 	– объект localStorage или sessionStorage, где произошло обновление.


					-Object.keys для получения всех ключей.
					-Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событие storage не срабатывает.

				3)Встроенная база данных:
					/*IndexedDB имеет встроенный механизм «версионирования схемы», который отсутствует в серверных базах данных.

					/*Мы можем хранить почти любое значение, в том числе сложные объекты. Каждому значению в хранилище должен соответствовать уникальный ключ.
					/*если открыть предыдущую версию - возникнет ошибка, сработает openRequest.onerror
					/*база данных может быть только одна
					/*Пример объекта, который нельзя сохранить: объект с циклическими ссылками
					/*Ключ должен быть одним из следующих типов: number, date, string, binary или array

					/*Хранилище объектов можно создавать/изменять только при обновлении версии базы данных в обработчике upgradeneeded.

					/*Все операции с данными в IndexedDB могут быть сделаны только внутри транзакций.
					/*Когда все запросы завершены и очередь микрозадач пуста, тогда транзакция завершится автоматически.
					/*При ошибке в запросе соответствующая транзакция отменяется полностью, включая изменения, сделанные другими её запросами.

					/*События IndexedDB всплывают: запрос → транзакция → база данных(request -> transaction -> db)  (event.stopPropagation() - остановка всплытия)

					1)Создание/Удаление базы/хранилищ:

						indexedDB.open(name, version) 		-отклрывает базу и возвращает объект для обработки событий <openRequest> (name – название базы данных, строка; version – версия базы, по умолчанию 1)
							.result 							-объект для работы с баззой данных <db>
								.createObjectStore(name, [keyOptions]) 	-создание хранилища объектов и возвращает хранилище <ObjectStore>(синхронная операция)
								.deleteObjectStore(name) 				-удаление хранилища объектов
								.objectStoreNames 						-список существующих хранилищ объектов

								.transaction(store,[type]) 				-возвращает спец объект <transaction> и начинает транзакцию
									.objectStore(name) 		 			-возвращает хранилище <store>
										.delete(query) 					-удаляет значения 
										.clear() 						-очищает хранилище

										.put(value, [key]) 				-добавляет значение value в хранилище. Если ключ уже существует - значение будет заменено.
										.add(val, [key]) 				-добавляет значение value в хранилище. Если ключ уже существует - запрос не выполнится(будет сгенерирована ошибка - "ConstraintError")
											.result 					-ключ нового объекта
											.error
										/*выполнить запрос на добавление элемента в хранилище(если успешно - добавляется). Возвращается объект для обработки событий <request>
									.abort() 							-отменит все изменения, сделанные запросами в транзакции, и сгенерирует событие abort

						indexedDB.deleteDatabase(name) 		-удаляет базу и возвращает объект для обработки событий-deleteRequest



						События для openRequest(можно настроить обработчики событий):
							success  			-база данных готова к работе, готов «объект базы данных» openRequest.result, его следует использовать для дальнейших вызовов.
							error 				-не удалось открыть базу данных.
							upgradeneeded  		-база открыта, но её схема устарела.
							blocked 			-если не закроем старую базу данных

						События для db(можно настроить обработчики событий):
							success  			-успех.
							error 				-ошибка.
							versionchange 		-при попытке обновления

						События для transaction
							success  			-успех.
							error 				-ошибка.
							complete 			-момент успешного выполнения транзакции
							abort 				-генерируется при вызове метода .abort()

						События для request(можно настроить обработчики событий):
							success  			-успех.
							error 				-ошибка.
								(event)
									.preventDefault() 		-продолжить транзакцию

					2)Поиск в хранилище
						/*Есть два основных вида поиска в хранилище объектов:
						/*-По ключу или по диапазону ключей. То есть: по book.id в хранилище «books».
						/*-По полям объекта, например, book.price.

						1)По ключу/диапазону ключей
							store 							-объект хранилища(query может быть либо точным ключом, либо диапазоном ключей)
								.get(query) 					– поиск первого значения по ключу или по диапазону.
								.getAll([query], [count]) 		– поиск всех значений, можно ограничить, передав count.
								.getKey(query) 					– поиск первого ключа, который удовлетворяет запросу, обычно передаётся диапазон.
								.getAllKeys([query], [count]) 	– поиск всех ключей, которые удовлетворяют запросу, обычно передаётся диапазон, возможно ограничить поиск, передав count.
								.count([query]) 				– получить общее количество ключей, которые удовлетворяют запросу, обычно передаётся диапазон.
							/*возвращают request с результатом в request.result

							
							IDBKeyRange 									-объект для создания диапазона 
								.lowerBound(lower, [open]) 						-возвращает диапазон(означает: >lower (или ≥lower, если open это true))
								.upperBound(upper, [open]) 						-возвращает диапазон(означает: <upper (или ≤upper, если open это true))
								.bound(lower, upper, [lowerOpen], [upperOpen]) 	-возвращает диапазон(означает: между lower и upper, включительно, если соответствующий open равен true)
								.only(key)  									-возвращает диапазон(состоит только из одного ключа key, редко используется)

						2)По полям
							/*Индексы должны создаваться в upgradeneeded, как и хранилище объектов
							/*Индексы автоматически обновляются

							ObjectStore
								.createIndex(name, keyPath, [options]) 	-создание индекса

							store
								.index(name) 							-возвращение части хранилища <store> по индексу(name-имя ранее созданного индекса)
							/*далее можно применять методы .get, .getAll, .getKey, .getAllKeys, .count

					3)Курсор:
						/*Объект cursor идёт по хранилищу объектов с заданным запросом (query) и возвращает пары ключ/значение по очереди, а не все сразу. Это позволяет экономить память.
						/*Основным отличием курсора является то, что request.onsuccess генерируется многократно: один раз для каждого результата.

						store 		-объект хранилища(query может быть либо точным ключом, либо диапазоном ключей)
							.openCursor([query], [direction]) 		-возвращает request с курсором в request.result


						request.result
							.advance(count) 	– продвинуть курсор на count позиций, пропустив значения.
							.continue([key]) 	– продвинуть курсор к следующему значению в диапазоне соответствия (или до позиции сразу после ключа key, если указан).

							//*Для курсоров по индексам
							.key  				-является ключом индекса (например price)
							.primaryKey 		-следующий ключ в хранилище объектов
							.value 	 			-следующее значение в хранилище объектов

						



					Аргументы:

						.createObjectStore(name, [keyOptions])
							name 			–название хранилища
							keyOptions 		–необязательный объект с одним или двумя свойствами(генерация ключа - если не указать keyOptions, то потребуется явно указать ключ позже, при сохранении объекта):
								.keyPath 		–путь к свойству объекта, которое IndexedDB будет использовать в качестве ключа(например id)
								.autoIncrement 	–если true, то ключ будет формироваться автоматически для новых объектов, как постоянно увеличивающееся число.

						.transaction(store,[type]) 
							store 	–название хранилища, к которому транзакция получит доступ. Может быть массивом - доступ к нескольким хранилищам.
							type 	–тип транзакции, один из:
								"readonly" 		– только чтение, по умолчанию.
								"readwrite" 	– только чтение и запись данных, создание/удаление самих хранилищ объектов недоступно.

						.createIndex(name, keyPath, [options]) 	-создание индекса и возвращение нового хранилища <store>
							name 		– название индекса,
							keyPath 	– путь к полю объекта, которое индекс должен отслеживать (мы собираемся сделать поиск по этому полю),
							options 	– необязательный объект со свойствами:
								.unique 	– если true, тогда в хранилище может быть только один объект с заданным значением в keyPath. Если мы попытаемся добавить дубликат, то индекс сгенерирует ошибку.
								.multiEntry – используется только, если keyPath является массивом. В этом случае, по умолчанию, индекс обрабатывает весь массив как ключ. Но если мы укажем true в multiEntry, тогда индекс будет хранить список объектов хранилища для каждого значения в этом массиве. Таким образом, элементы массива становятся ключами индекса.

						.openCursor([query], [direction]);
							query  			-ключ или диапазон ключей, как для getAll.
							direction 		-необязательный аргумент, доступные значения:
								"next" 			– по умолчанию, курсор будет проходить от самого маленького ключа к большему.
								"prev" 			– обратный порядок: от самого большого ключа к меньшему.
								"nextunique", "prevunique" 	– то же самое, но курсор пропускает записи с тем же ключом, что уже был
								(только для курсоров по индексам, например, для нескольких книг с price=5, будет возвращена только первая).



	10)Проверка кода:

		1)Тестирование(Mocha)

			describe("заголовок", function() { ... })
			it("описание", function() { ... })

			assert.equal(value1, value2)
			assert.strictEqual(value1, value2)
			assert.notEqual
			assert.notStrictEqual
			assert.isTrue(value)
			assert.isFalse(value)

		2)Обработка ошибок:
			/*Нужно использовать проброс исключения(не забыть про: name, super)
			/*Для пользовательских ошибок использовать наследие от Error(для проверки типа ошибок: instanceof, name)
			/*Для удобства делать обертывание исключений в отдельный класс(наследует от Error, имеет св-во cause)

			try {
			  // исполняем код
			} catch(!имя!) {
			  // если случилась ошибка, прыгаем сюда
			  // !имя! - это объект ошибки
			} finally {
			  // выполняется всегда после try/catch
			}
			/*можно без finally или catch
			/*можно не использовать (!имя!)

			/*Объекты ошибок содержат следующие свойства:
			/*message 	– понятное человеку сообщение.
			/*name 		– строка с именем ошибки (имя конструктора ошибки).
			/*stack 	– стек на момент ошибки(нестандартное, но хорошо поддерживается)


			throw obj 		-генерирует ошибку с объектом ошибки obj
			/*Конструкторы для стандартных ошибок: Error, SyntaxError, ReferenceError, TypeError ...

			window.onerror = function(message, url, line, col, error) { ... } 		-  св-во - функция в браузере, которая будет вызвана в случае необработанной ошибки
			/*message 	-Сообщение об ошибке.
			/*url 		-URL скрипта, в котором произошла ошибка.
			/*line, col 	-Номера строки и столбца, в которых произошла ошибка.
 			/*error 		-Объект ошибки.

 	11)Модули:
 		/*type = "module" 	-приравниваем атрибут, чтобы скрипт стал модулем(для работы import/export)
 		/*Внешний скрипт, который загружается с другого домена, требует указания заголовков CORS.
 		/*Дублирующиеся внешние скрипты игнорируются
 		/*У каждого модуля своя область видимости
 		/*Код в модулях выполняется только один раз

 		export !announce!						-отмечает объявленные переменные, которые должны быть доступны вне текущего модуля.
 			{!name!, ...} 							-отдельно от объявления
 			{!name! as !newName!, ...} 				-экспорт переменных со своим именем

 			default !announce! 							
 			{!name! as default, ...}  				-экспорт по умолчанию(экспорт по умолчанию только один)


 		import !src! 							-только подключить модуль (его код запустится)
		import {!name!, ...} from !src! 		-позволяет импортировать из других модулей.
			* as !objName! 							-импорт всего в объект(!objName!.default - то что в экспорте по умолчанию) 
 			{!name! as !newName!, ...} 				-импорт переменных со своим именем

 			!name! 									
 			{default as !name!, ...}				-импорт по умолчанию(можно дать любое имя) 		



 		import(module) 								-загружает модуль и возвращает промис, результат - объект модуля, содержащий все его экспорты(!objName!.default - то что в экспорте по умолчанию) 
 		/*не нужен type = "module"
 		/*это не ф-ция а спец синтаксис


 		import.meta  						-содержит информацию о текущем модуле.
 		export ... from ... 				-реэкспорт

 	12)Бинарные данные и файлы:

 		1)ArrayBuffer/TypedArray
			new ArrayBuffer(byte) 		-конструктор для буфера "бинарные данные"(byte - кол-во битов)
				.byteLength 			-кол-во байтов в буфере
			/*Базовый объект для работы с бинарными данными

			Uint8Array()
			Uint8Array(typedArray)
			Uint8Array(object)
			Uint8Array(buffer, [byteOffset], [length]) 		-конструктор для объекта-представления буфера
				.length 										-кол-во чисел в буфере
				.byteLength 									-размер содержимого ArrayBuffer в байтах.
				.buffer 										-ссылка на объект ArrayBuffer
				Uint8Array.BYTES_PER_ELEMENT					-кол-во байт на каждое число
			...
			/*Специальный объект(TypedArray), реализующий «представление» данных. Является псевдо-массивом



			DataView(buffer, [byteOffset], [byteLength]) 	-конструктор для гибкого объекта-представления буфера(не имеет типа)
				.get...(pos) 									-доступ к данным нужного типа 	

		2)TextEncoder/TextDecoder

			TextDecoder([label], [options]) 	-конструктор для объекта, который декодирует из бинарного буфера в строку(label- тип кодировки,options- настройки)
				.decode([input], [options]) 		-метод для декодирования(input – бинарный буфер,options- настройки)

			TextEncoder() 						-конструктор для объекта, который кодирует строку в бинарный массив
				.encode(str) 						– возвращает бинарный массив Uint8Array, содержащий закодированную строку.
				.encodeInto(str, destination) 		– кодирует строку (str) и помещает её в destination, который должен быть экземпляром Uint8Array.
			/*Поддерживается только кодировка «utf-8».

		3)Blob

			new Blob(blobParts, [options]) 		-конструктор для высокоуровневого «бинарные данные с типом» объекта(blobParts – массив значений Blob/BufferSource/String, options- настройки)
				.slice([byteStart], [byteEnd], [contentType]) 	-возвращает срез Blob
			/*Blob не изменяется как и строки

				/*Скачивание файла используя Blob как URL
					let link = document.createElement('a');
					link.download = 'hello.txt';

					let blob = new Blob(['Hello, world!'], {type: 'text/plain'});

					link.href = URL.createObjectURL(blob);

					link.click();

					URL.revokeObjectURL(link.href);
				


				/*Скачивание файла используя Blob to base64
					let link = document.createElement('a');
					link.download = 'hello.txt';

					let blob = new Blob(['Hello, world!'], {type: 'text/plain'});

					let reader = new FileReader();
					reader.readAsDataURL(blob); // конвертирует Blob в base64 и вызывает onload

					reader.onload = function() {
					  link.href = reader.result; // url с данными
					  link.click();
					};
					

				/*Скачивания изображения в Blob
					//Для отрисовки изображения (или его части) на холсте (canvas) используется canvas.drawImage.
					// toBlob является асинхронной операцией, для которой callback-функция вызывается при завершении
					canvas.toBlob(function(blob) {
					  // после того, как Blob создан, загружаем его
					  let link = document.createElement('a');
					  link.download = 'example.png';

					  link.href = URL.createObjectURL(blob);
					  link.click();

					  // удаляем внутреннюю ссылку на Blob, что позволит браузеру очистить память
					  URL.revokeObjectURL(link.href);
					}, 'image/png');
				

				/*Получаем arrayBuffer из Blob
					let fileReader = new FileReader();

					fileReader.readAsArrayBuffer(blob);

					fileReader.onload = function(event) {
					  let arrayBuffer = fileReader.result;
					};

		4)File/FileReader
			/* File наследуется от объекта Blob

			new File(fileParts, fileName, [options]) 		-конструктор создания объекта-файла(fileParts – массив значений Blob/BufferSource/строки, fileName – имя файла, строка, options – доп настройки)
				.name 											– имя файла,
				.lastModified 									– таймстамп для даты последнего изменения.
			/*Второй способ получения - <input type="file"> или другое взаимодействие с браузером
			/*input.files -псевдомассив с загруженными в input файлами


			
			new FileReader() 		-конструктор создания объекта-считывателя(считывает данные из Blob и File)
				.readAsArrayBuffer(blob) 			– считать данные как ArrayBuffer
				.readAsText(blob, [encoding]) 		– считать данные как строку (кодировка по умолчанию: utf-8)
				.readAsDataURL(blob) 				– считать данные как base64-кодированный URL.
				.abort() 							– отменить операцию.

				/*Свойства получаемые после чтения
				.result 							-результат чтения (если оно успешно)
				.error 								-объект ошибки (при неудаче).
			/*Данные передаются при помощи событий, так как чтение с диска может занять время.

			/*В процессе чтения происходят следующие события для reader - объекта-считывателя(можно настроить обработчики событий):
			/*loadstart 		– чтение начато.
			/*progress 			– срабатывает во время чтения данных.
			/*load 				– нет ошибок, чтение окончено.
			/*abort 			– вызван abort().
			/*error 			– произошла ошибка.
			/*loadend 			– чтение завершено (успешно или нет).


		


^Особенности/Определения:

	1)Конструктор:
		new.target
		return (obj, this, noObj)

	2)THIS:
		- на верхнем уровне скрипта он =window(но не в модуле)
		- не фиксированный(смотрит на то что стоит слева от точки)
		- у стрелочных функций нет своего this
		- точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа»

	3)Полифил:
		- нужен для преобразования кода под старые браузеры
		.

	4)События:

		Все события:
			click, dblclick, contextmenu, mouseover/mouseout,mouseenter/mouseleave, mousedown/mouseup, mousemove
			keydown/keyup
		 	dragstart/dragend
		 	pointercance,lostpointercapture,gotpointercapture, pointer(mouse)
		 	focus/blur, focusin/focusout
		 	change, input, cut, copy, paste
		 	submit, DOMContentLoaded, load, beforeunload, unload, readystatechange
		 	load, error, unhandledrejection



	Итерируемые объекты 		– это объекты, которые реализуют метод Symbol.iterator.
	Псевдомассивы 				– это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.
	Контекст выполнения 		– спец. внутренняя СД, которая содержит информацию о вызове функции(конкретное место в коде; локальные переменные функции; значение this ...)
	Лексическое окружение 		– это специальный внутренний объект
	Замыкание 					– это функция, которая запоминает свои внешние переменные и может получить к ним доступ

	Инкапсуляция 				- отделение внутреннего интерфейса от внешнего
	Внутренний интерфейс 		– методы и свойства, доступные из других методов класса, но не снаружи класса.
	Внешний интерфейс 			– методы и свойства, доступные снаружи класса.
	Примесь	 					– это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси

	Проброс исключения 			– приём обработки ошибок: catch должен пробрасывать дальше ошибки, о которых он не знает.

	Document Object Model(DOM)	– объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.
	Browser Object Model(BOM) 	– объектная модель браузера,  это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

	Дочерние узлы (или дети) 	– элементы, которые лежат непосредственно внутри данного
	Потомки 					– все элементы, которые лежат внутри данного, включая детей, их детей и т.д.
	Предки элемента 			– родитель, родитель родителя, его родитель и так далее

	Атрибуты 					– это то, что написано в HTML.
	Свойства 					– это то, что находится в DOM-объектах.

	Обработчик события 			- ф-ция которая вызывается при событии

	SQL 						— реляционная база данных, данные хранятся в формате таблиц, они строго структурированы и связаны друг с другом. В таблице есть строки и столбцы, каждая строка представляет отдельную запись, а столбец — поле с назначенным ей типом данных. В каждой ячейке информация записана по шаблону.
	NoSQL 						— нереляционная база данных, хранит данные без четких связей друг с другом и четкой структуры. Вместо структурированных таблиц внутри базы находится множество разнородных документов, в том числе изображения, видео и даже публикации в социальных сетях. В отличие от реляционных БД, NoSQL базы данных не поддерживают запросы SQL.

	SPA 						-single page application(работа с одним HTML, используя JS)
	В программировании неизменяемым (англ. immutable) называется объект, состояние которого не может быть изменено после создания.

	AJAX 						-аббревиатура от Asynchronous JavaScript And XML

	Простой зарос 				-это запрос, удовлетворяющий следующим условиям: Простой метод(GET, POST, HEAD), Простой заголовок


	Бинарные данные:
	ArrayBufferView 	– это общее название для представлений всех типов.
	BufferSource 		– это общее название для ArrayBuffer или ArrayBufferView.




	TREE:

		
		Breadth first search(BFS) 		-обход дерева в ширину(очередь)
		Depth first search(DFS)			-обход дерева в глубину(стек/рекурсия)

		Pre-order traversal 			-прямой обход дерева в глубину
		In-order traversal 				-поперечный обход дерева в глубину(центрированный/симметричный)
		Post-order traversal 			-обратный обход дерева в глубину

		Binary search tree(BST) 		-двоичное дерево, где у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X;
										 и где у всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны, нежели значение ключа данных самого узла X.


^Библиотеки/Фреймверки/...:

	Node.js:

		1)Инициализация проекта:
			npm init 		-создает package.json
			node !filename! -запускает файл	

		2)Доступные переменные Node
			require 		-возвращает объект модуля(импорт)
			__dirname 		-путь к папке где храниться файл
			__filename 		-путь к файлу

		3)Встроенные модули:

			1)path:
				const path = require("path") 		-получение объекта модуля

				path
					.join()

					.basename()
					.dirname()
					.extname()
					.parse()
						.name

			2)fs:
				const fs = require("fs") 			-получение объекта модуля

				fs
					.mkdir(path,func)
					.whiteFile(path, body, func)
					.appendFile(path, body, func)
					.readFile(path, enc, func)

			3)events:
				const EventEmitter = require("events") 	-получение класса модуля

				const emitter = new Eventemitter() 	

				emitter
					.on() 			-создание обработчика события
					.emit() 		-создание события


			4)http:
				const http = require("http")

				http
					.createServer(func(req,res))
						.listen()

				req
					.end()
					.writeHead()

					.url

		4)process:
			/*Хранит константы

			process.env.PORT 		-порт сервера

		5)Terminal(npm/npx):
			/* maj.min.pat 	-версия пакета
			/*		~ 							-разрешает обновление только патча
			/*		^ 							-разрешает обновление до минора
			/*		* 							-разрешает полное обновление(до мажора)

			Сокращения:
				install 	i
				uninstall	un
				update 		up

			npm init 					-создает package.json
			npm init --yes 				-создает package.json с дефолтными настройками
				dependencies 				-зависимости
				devDependencies 			-зависимости для разработки
				scripts 					-объект со строками-командами 
			
			npm run !script! 	-запускает строку которая прописана по ключу в scripts


			npm install !pack! 			-установка библиотеки
			npm install !pack!@!ver!	-установка библиотеки с определенной версией
			npm install !pack! 			-установка библиотеки как dev зависимость
			npm install 				-установка всех зависимостей
			npm install --production 	-установка всех зависимостей без devDep

			npm uninstall !pack! 			-удалить библиотеку


			npm list !pack! 				— покажет версию установленного пакета, 
			npm view !pack! version 		— последнюю версию пакета, которая существует.
			npm update !pack!  			- обновит пакет до последней версии
			npm update  				- обновит все пакеты до последней версии



			npm list --depth=0 			-список всех установленных пакетов(не включая их зависимостей)
			npm outdated --depth=0 		-список пакетов которые нужно обновить



			npm update npm -g  			-позволяет обновить версию npm



			node !filename! -запускает файл	
			nodemon

	React:

		1)Запуск/Подготовка
			/*В .render  <App/> помещается в "root"

			-npx create-react-app
				.
				!name!

			html:
    			<div id="root"></div>
    			.

			index:


				import React from 'react';
				import ReactDOM from 'react-dom';
				import App from './App';

				ReactDOM.render(
				  <App/>,
				  document.getElementById('root')
				);


			App:

				import React from "react";

				function App(){

					return(!objJSX!);
				}

				export default App;

			-npm start(terminal)



			Структура папок:

				node_modules
				public
					index.html
				src
					components
						UI
							comp1
								... .jsx
								... .module.css
							comp2
							...
						comp3
						comp4
					hooks
						... .js
					utile
						... .js
					styles
						... .css

					App.js
					index.js

		2)objJSX:
			/*Почти все как в HTML*/
			/*JSX возвращает объект созданный по разметке*/
			/*Работаем с Virtual DOM поэтому не используем стандартные ф-ции для DOM (не используем document)*/

			{} 		 		-js код который возвращается(внутри может быть: строка, число, усл, компонента, handler ф-ции(для событий), массив этих элементов, ... -- выражение js)
			/*для массивов нужно определять ключ элементов непосредственно

			<>...</> 			-вернет только внутренности

			Особенности атрибутов:
				className 		-атрибут class(все в виде camelCase)
				on!Event! 		-Для подключения события передаем handler ф-ции через {} (не работает: return false)
				ref 			-содержит ссылку созданную React-ом по которой можно обращаться к элементу 
				key 			-ключ для элемента массива(не может читаться)

		3)Компоненты
			/*Ф-ции возвращающие JSX (или классы)
			/*Пишутся с заглавной буквы
			/*State внутренних компонент не изменяется при перерендере родителя

			Comp:
				/*возвращает ОДИН тег
				/*для return либо скобки() либо на той же строке тег
				/*вызов как <Comp/>

				import React from "react";

				const Comp = (!props!) =>{

				    return(!objJSX!);
				};

				export default Comp;

			props:
				/*объект который передается в компоненту со св-ми как атрибуты

				<Comp prop1="..." prop2="..." prop3={...}/>

					props=={
						prop1: ...
						prop2: ...
						prop3: ...
					}

					props.children 		-хранит в себе дочерние элементы Comp

			Управляемые компоненты:
				/*изменяем value через onChange и state

			Композиция:
				Вставка 			-использование props.children или компонент в своих атрибутах
				Специализация 		-настраиваниие "частного" Comp через общий и props

		4)Стили

			Модуль:

				import !obj! from "!...!.module.css"

				obj 		-объект в котором св-ва это стили внутри модуля

			Обычные:

				import "!...!.css"

		5)Хуки
			/*это функции, с помощью которых можно «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов
			/*следует вызывать только из функциональных компонентов React, только на верхнем уровне(в пользовательских хуках)

			import { !имя хука! } from 'react'; 	-для использования

			1)useState(init) 			-состояние, отслеживаемая и сохраняемая переменная - происходит новый рендер  компоненты при изменении переменной сеттером(return [state, setState])

			2)useEffect(func,deps) 		-даёт возможность выполнять побочные эффекты после каждого рендера компоненты и обновления DOM - вызов ф-ции при монтировании
				/*Побочными эффектами в React-компонентах могут быть: загрузка данных, оформление подписки и изменение DOM вручную.

				func(){ 				-функция которая вызывается при запуске useEffect для побочных эффектов

					return func2 		-функция которая вызывается при размонтировании компонента
				}

				useEffect(func) 		-запуск при новом рендере
				useEffect(func, []) 	-запуск один раз при первом рендере
				useEffect(func, [...]) 	-запуск каждый раз при изменении зависимостей
			
			3)useContext(cont) 			-возвращает value из провайдера в любой компоненте внутри

				createContext(init) 		-создание контекста, возвращает контекст(cont) для использования в useContext(init - дефолт для value)

				Пример применения:
					import {createContext} from 'react'
					const MyContext = createContext(null) 	
					***
					<MyContext.Provider value={..}> 	
						... 								-в компонентах внутри можно использовать useContext
					</MyContext.Provider>	
					***
					сonst val = useContext(MyContext) 		-получение value из провайдера в компоненте внутри


			4)useNavigate() 			-возвращает функцию, которая может менять url (func(url) - изменит url)
			5)useLocation() 			-возвращает объект с данными url(path, ...)
			6)useParams() 				-для компоненты в Routes вернет объект с данными url		

				


			useRef 						-хранит объект в св-ве current, который не изменяется при рендере компонента
			useMemo(func, deps) 		-вызывает ф-цию если изменились deps, и возвращает возвращенное из func значение
			useCallback

			Пользовательские:
				/*стоит именовать use..
				/*ф-ция использующая другие хуки

		6)Методы и ф-ции React:
			.createRef() 		-создает ссылку (useRef)
				.current 			-св-во ссылающееся на HTML элемент

			createContext(defVal) 	-создает контекст

		7)Подключения

			React router

				npm i react-router-dom 				-установка

				
				<BrowserRouter> 				-обертка для работы route, link

					<Routes>						-обертка для работы route
						<Route  						-один из путей(следит за адресной строкой, возвомжна вложенность-path строится от родителя к дочерним элементам)	
							element ={}						-компонента отрисованная по путю(вставляется компонента с ее пропсами)
							path 	=""						-путь(:param 	-динамический маршрут)
						/>
						...
					</Routes>

					<Link 							-меняет путь как тег <a> без перезагрузки
						to ="" 				 			-новый путь
					>
						... 						-сама ссылка
					</Link>

					<NavLink 						-такая же ссылка, но с активным классом
						to ="" 							-новый путь

						style=...
						className={{isActive}=>{}} 		-стиль можно задать ф-цией, которая принимает объект со св-вом isActive, а возвращается сам стиль
					>
						...
					</NavLink>

					...
				</BrowserRouter>

			Redux
				/*- type в action задавать константами
				/*- action возвращать ф-циями(actionCreator)	

				createStore(reducer) 				-создает и возвращает store
				combineReducers(obj)				-объединяет все reducer-ы в один


				function reducer(state, action){ 	-шаблон reducer-а
					switch(action.type)
						case ...:
							...
							return ...
						case ...:

							return ...
						default: 
							return state
				}

				Определения:

					store 					- объект для управления состоянием
					state 					- состояние, объект где хранится вся информация приложения
					reducer 				- это просто чистые функции, которые берут предыдущее состояние и экшен и возвращают новое состояние
					action 					- объект, который описывает, что случится(св-во type обязательно)
					dispatch 				- ф-ция в которую помещается экшен и которая вызывает reducer

					actionCreator 			- ф-ция возвращающая action

			React Redux:

				Provider 		-компонента принимающая store, всем компонентам внутри он будет доступен

				useDispatch() 				-вернет dispatch
				useSelector(func(state)) 	-получает состояние и возвращает данные из него
					

			Axios. API

			React transition group

			Intersection Observer

	Webpack:

		1)Подготовка
			npm i -D webpack webpack-cli
			npm init
				scripts
					"dev":"webpack --mode development" 							-для запуска webpack в режиме dev
					"build": "webpack --mode production" 						-для запуска webpack в режиме prod
					"watch":"webpack --mode development --watch" 				-для запуска webpack в режиме watch dev(не закончит выполнение webpack-постоянное обновление)
					"start": "webpack-dev-server --mode development --open" 	-


			-создать файл webpack.config.js:
			-использовать в index.html только результат

		2)config:

			const path = require("path")
			const HTMLWebpackPlugin = require("html-webpack-plugin")
			const {CleanWebpackPlugin} = require("clean-webpack-plugin")
			const CopyWebpackPlugin = require("copy-webpack-plugin")
			const MiniCssExtractPlugin = require("mini-css-extract-plugin")

			module.exports = {
			  context: path.resolve(__dirname, "...") 	-указывает папку из которой беруться файлы 
			  mode: "development", 						-не минифицировать результат(можно менять запуском нужной команды: webpack --mode ...)
			  entry: { 									-входные файлы(может быть одной строкой) - кол-во = кол-во результатов => используем динамический filename
			  	...: "...", 						
			  	...: "...",
			  }
			  output: { 								-где будет храниться результат
			    filename: "bundle.js", 						-файл с результатом([name],[contenthash])
			    	[name]										-имя будет браться из св-ва entry
			    	[contenthash] 								-создается новый hash при изменении контента
			    path: path.resolve(__dirname, "dist") 		-папка с результатом
			  },


			  plugins:[ 								-позволяет подключать различные плагины
			  	new HTMLWebpackPlugin({ 	 				-создает свой html с подключенными скриптами-результатами
			  		template: "..." 						-путь к html-будет использоваться именно этот файл
			  		minify:{
			  			collapseWhitespace: true 			-для минификации html
			  		}
			  	}),
			  	new CLeanWebpackPlugin(), 					-каждый раз очищает папку с результатом и остается только новый результат
			  	new CopyWebpackPlugin([ 					-копирует файл из одного места в другое
			  		{
			  		from:
			  		to:
			  		}
			  	])
			  	new MiniCssExtractPlugin({ 		 			-создает файл .css
			  		filename: "..." 						
			  	}) 					
			  ],


			  module:{
			  	rules: [ 								-правила по которым происходят импорты различных форматов
			  		{
			  			test: /.../, 					-задать форматы
			  			use: ["...",...]				-использование нужного loader(использование справа-налево)
			  		}
			  		{
			  			test: ...,
			  			use: [{
			  				loader: "...",
			  				options: {
			  					...
			  				}
			  			}, {}, "...", ...]
			  		}
			  		{
			  			test: ...,
			  			exclude: /node_modules/,
			  			loader: ...
			  		}
			  	]
			  }

			  devtool: "sourse-map" 					-карты которые помогают при debug (DEVELOP)
			  resolve: {
			  	extensions: ["...", ...] 				-стандартные форматы при импорте
			  	alias:{
			  		"@..." : path.resolve(...) 			-задать переменную-путь для импортов
			  		...
			  	}
			  }
			  optimization:{
			  	splitChunks:{
			  		chunks: "all" 						-оптимизация(напр: при одинаковом подключении библиотеке в двух скриптах)
			  	}
			  	minimizer:[								-(PRODACTION)
			  		new OptimizeCssAssetWebpackPlugin() 	-для минификации .css
			  		new TerserWebpackPlugin() 				-для минификации .js
			  	]
			  }
			  devServer:{
			  	port: ... 								-для моментального обновления
			  }

			}

		3)install:
			npm i -D webpack-bundle-analyzer
			npm i -D webpack webpack-cli
			npm i -D webpack-dev-server


			npm i -D html-webpack-plugin
			npm i -D clean-webpack-plugin
			npm i -D copy-webpack-plugin

			npm i -D mini-css-extract-plugin
			npm i -D optimize-css-assets-webpack-plugin
			npm i -D terser-webpack-plugin


			
			npm i -D css-loader style-loader
			npm i -D file-loader

			npm i normalize.css


			npm i @babel/polyfill
			npm i -D @babel/core @babel/preset-env 	babel-loader 
			npm i -D less 			less-loader
			npm i -D node-sass 		sass-loader

	Bootstrap:

		1)Подготовка:
			npm init
			npm i bootstrap 
			/*либо используем специальные ссылки

			/*через link  используем то что нужно

			bootstrap-grid.css 			-файл со стилями для сеток
			bootstrap-reboot.css 		-файл со стилями для сбрасывания стандартных стилей + кроссбраузерность
			bootstrap-utilities.css 	-файл со стилями утилитами
			bootstrap.css 				-файл со стилями включающами все 	

			
			bootstrap.js 				-файл с кодом
			bootstrap.esm.js 			-файл-модуль с кодом
			bootstrap.bundle.js 		-файл с кодом включающим Popper

		2)Классы
			/*BP - sm/md/lg/xl/xxl 		-условия ширины(без условия ставиться xs)

			1)Сетка
				/*сетка разбита на 12 столбцов
				/*для обрыва можно использовать: <div class="w-100"></div>
				/*в основе лежит flex

				1)Контейнеры:
					/*num- 1-12/auto

					container 			-контейнер(выравнивается в центре) 
					container-fluid		-контейнер всегда 100% ширина
					container-!BP! 		-контейнер по ширине


					row 				-создать строку-контейнер
					col 				-создать элемент строки-контейнера(без доп классов занимает оставшееся место поровну с другими col)	


					СВ-ВА КОНТЕЙНЕРОВ:

						row-cols-!num! 		-разбить на столбцы

						g-!n!
						gx-!n!
						gy-!n!


						col-!BP!			-элемент по ширине
						col-!num! 			-элемент занимает num/12 часть(auto - по содержимому)
						col-!BP!-!num! 		-объединение

						offset-!BP!-!num! 	-увеличивает левое поле столбца в зависимости от ширины


				2)Св-ва FLEXBOX в классах:
					/*Установка св-в классами

						ДЛЯ КОНТЕЙНЕРА:


							justify-content-!BP!-!val!
								val-	start/center/end/around/between/evenly

							align-items-!BP!-!val!
								val-	start/center/end/baseline/stretch
							align-content-!BP!-!val!
								val-	center/end/around/between/stretch

							flex-!BP!-!direction!
								direction-	row/row-reverse/column/column-reverse

							flex-!BP!-!wrap!
								wrap-	wrap/nowrap/wrap-reverse

						ДЛЯ ЭЛЕМЕНТА:

							align-self-!BP!-!val!
								val-	start/center/end/baseline/stretch

							order-!BP!-!num! 		
								num-	(1-5)/first/last	

							flex-!BP!-fill 		-место занимаемое содержимым(или равное остальным если содержимого мало)

							flex-!BP!-grow-!val!
							flex-!BP!-shrink-!val!
								val-	1/0	



			2)Утилиты

				1)Spacing:

					!prop!!sides!-!BP!-!size! 		-задать margin или padding
						prop 	-m/p 					-margin или padding
						sides	-t/b/l/r/x/y/.. 		-по каким сторонам(без sides - по всем сторонам)
						size 	-0-5/n!0-5!/auto

					float-!BP!-!sides! 				-задать float
						sides- 	left/right/none

					border 							-установить границы вокруг
					border-!sides! 					-установить границу на стороне
					border-0 						-убрать границы вокруг
					border-!sides!-0 				-убрать границу на стороне
						sides- 	top/bottom/left/right
					rounded 						-радиус границы вокруг
					rounded-!val! 					-определенный радиус
						val- 	top/bottom/left/right (для сторон)/ pill/circle/0
					rounded-!size! 					-размер радиуса
						size- 	sm/lg 	

				2)Colors:

					text-!col! 			-цвет текста в блоке
					text-reset 			-цвет текста как у родителя
					link-!col! 	 		-цвет ссылки(имеют состаяния hover, focus)
					bg-!col! 	 		-цвет фона
					border-!col! 		-цвет границ
						col- 	primary/secondary/success/danger/warning/info/light/dark/body/muted/white/black-50/white-50  /transparent 

					bg-gradient 		-добавление градиента к фону(сверху-вниз светлый-темный)

				3)Отображение

					d-!BP!-!val! 		-установка отображения(display)
					d-print-!val! 		-установка отображения при печати(принтером)
						val- 	none/inline/inline-block/block/table/table-cell/table-row/flex/inline-flex


					visible
					invisible 			-установка visibility

					position-!pos! 		-установка положения(position)
						pos- 	static/relative/absolute/fixed/sticky

				4)Шрифт/Текст

					text-!BP!-!align! 		-выравнивание
						align- 	left/center/right

					text-!wrap! 			-перенос вкл/выкл
						wrap- 	nowrap/wrap(по словам)/break(по словам и буквам)

					text-!transform! 		-капитализация текста
						transform- 	lowercase/uppercase/capitalize

					text-decoration-!dec! 	-декорация текста
						dec- 	underline/line-through/none


					font-weight-!val! 				-настройка толщины шрифта
						val- 	bold/bolder/light/lighter/normal
					font-italic 					-курсив
					font-monospace 					-моноширинный
					font-normal						-без стилей

					lh-!val! 						-высота строки
						val- 	1/sm/base/lg

				5)Размеры

					w-!%! 		-ширина
					h-!%! 		-высота
					mw-!%!  	-максимальная ширина
					mh-!%!  	-максимальная высота
			
					vw-!%! 		-ширина в vw
					vh-!%! 		-высота в vh
					min-vw-!%! 		-минимальная ширина в vw
					min-vh-!%! 		-минимальная высота в vh
						%- 25/50/75/100/auto


			3)Компоненты

				1)Аккордеон

					<div class="accordion" id="accordionExample">
						<div class="accordion-item">
					    	<h2 class="accordion-header" id="headingOne">
					      		<button class="accordion-button !collapsed!" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
					        		...
					      		</button>
					    	</h2>
					    	<div id="collapseOne" class="accordion-collapse collapse !show!" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
					      		<div class="accordion-body">
					        		...
					      		</div>
					    	</div>
					  	</div>
					  	...

					</div>


					accordionExample 					-меняем для нового аккордеона
					headingOne/collapseOne  			-меняем для нового элемента в аккордеоне

					collapsed			-добавляем если не развернуто по дефолту
					show 				-добавляем если развернуто по дефолту

				2)

			4)Доп

				1)Изображения 

					img-fluid 		-адаптив для изображения(подстраивается под родителя)
					

				2)Списки

					list-unstyled 		-список без стиля

					list-inline 		
					list-inline-item 	-для списков в линию

							




	express:
		/*фреймверк для создания сервера

		Router
			.post(adr, func(req, res))
			.get()
			.put()
			.delete()

				req
				res
					body
					params
					status
					json

		express()
			.use()
			.listen()

	mongoose:
		/*инструмент моделирования объектов в MongoDB(ODM)

		mongoose
			.connect()
			.Schema()

			.model()
				.create()
				.find()
				.findById()
				.findByIdAndUpdate()
				.findByIdAndDelete()

	mongodb:
		/*собственный драйвер для взаимодействия с экземпляром MongoDB




	VSC:

		Hot keys:

			Ctrl + D
			Ctrl + /
			Alt  + Click 
			F2


			Shift + Alt + F
			Ctrl + K Z

		Extensions:

			Emmet:
				< 	-внутри

				. 	-класс
				# 	-id

				*	-количество раз
				+ 	-на том же уровне

				{.. $} 	-текст внутри($ - перечисление)
				[..] 	-атрибут

	WS:

		Hot keys:

			Ctrl + Shift + N 		
			Ctrl + Click

			Ctrl + Alt + L
			
			Ctrl + /
			Ctrl + Shift + /

			Ctrl + D
			Ctrl + Y

			Alt + J
			Alt + Click

			Ctrl + Shift + NumPad+
			Ctrl + Shift + NumPad-

	Git:
		--system
		--global
		--local

		--list
		--unset
		--remove-section

		--hard
		--oneline

		-a
		-b

		master  	-основная ветка

		.gitignore 	-файл с именами папок и файлов которые должны игнорироваться

		^Команды:

			git
				init 		-создание гит репозитория в папке
				config 		-настройки конфигурации

				add 		-добавление файлов в стадию ожидания
				reset HEAD
				commit  	-добавление файлов в локальный репозиторий
					.
					folder/
					file
					*.ext
					!

				status 		-вывод статуса(находятся ли файлы в стадии ожидания, ветка)
				log 		-вывод истории коммитов

				checkout 	-открыть проект на коммите	
				revert 		-отменить изменения коммита
				reset 		-удалить все последующие коммиты(--hard удаляет и изменения)
					!index!
					!branch!

				merge 		-объединить с веткой
				branch 		-создать ветку
					-a 			-вывод всех веток
					-b 	 		-создать и перейти	
					!branch!

				remote add origin !ссылка! 		-подключение к github(origin - имя)
				push -u origin master 			-запушить в github(origin->master)

	Terminal

		ls
			-a
			-l
		cd 				-открыть
			..
			folder
		mkdir 			-создать папку
		rmdir 			-удалить папку
		cat 			-содержимое файла	
		clear

		aliac.!name! "!command!"


^Алгоритмы:

	1)Декоратор-кэш:

		1)Один аргумент не метод:

			function cachingDecorator(func) {
		  	let cache = new Map();

		 	return function(x) {
			    if (cache.has(x)) {    
			      return cache.get(x); 
			    }

			    let result = func(x); 

			    cache.set(x, result);
			    return result;
		  	};
			}

		2)Много аргументов и метод:

			function cachingDecorator(func, hash) {
			  let cache = new Map();
			  return function() {
			    let key = hash(arguments);
			    if (cache.has(key)) {
			      return cache.get(key);
			    }

			    let result = func.call(this, ...arguments);

			    cache.set(key, result);
			    return result;
			  };
			}

			function hash(args) {
			  return [...args].join();
			}

	2)Примесь для событий:

		let eventMixin = 
		{
		  on(eventName, handler) 
		  {
		    if (!this._eventHandlers) this._eventHandlers = {};
		    if (!this._eventHandlers[eventName]) {this._eventHandlers[eventName] = [];}
		    this._eventHandlers[eventName].push(handler);
		  },

		  off(eventName, handler) 
		  {
		    let handlers = this._eventHandlers && this._eventHandlers[eventName];
		    if (!handlers) return;
		    for (let i = 0; i < handlers.length; i++) 
		    {
		      if (handlers[i] === handler) {handlers.splice(i--, 1);}
		    }
		  },

		  trigger(eventName, ...args) 
		  {
		    if (!this._eventHandlers || !this._eventHandlers[eventName]) {return;}		    
		    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));
		  }
		};

	3)Оптимизация:

		1)Throttle

			function throttle(func, ms) {

			  let isThrottled = false,
			    savedArgs,
			    savedThis;

			  function wrapper() {

			    if (isThrottled) { // (2)
			      savedArgs = arguments;
			      savedThis = this;
			      return;
			    }

			    func.apply(this, arguments); // (1)

			    isThrottled = true;

			    setTimeout(function() {
			      isThrottled = false; // (3)
			      if (savedArgs) {
			        wrapper.apply(savedThis, savedArgs);
			        savedArgs = savedThis = null;
			      }
			    }, ms);
			  }

			  return wrapper;
			}

		2)Debounce

			function debounce(f, ms) {

			  let isCooldown = false;

			  return function() {
			    if (isCooldown) return;

			    f.apply(this, arguments);

			    isCooldown = true;

			    setTimeout(() => isCooldown = false, ms);
			  };

			}


^Фичи:

	1)Массивы:

			arr.slice() 					-копия arr
			arr.splice(ind,1) 				-удаление элемента по ind
			arr = Array.from(new Set(arr)) 	-удаление одинаковых элементов

