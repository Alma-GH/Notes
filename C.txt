C:\Forall\C_files

Следует изучить:
		1)как в ф-цию передавать двумерный массив

		2)switch()
		{ 
			case ..:
			default:
		}
		3)вывод с форматом
			%3.2f /* 3- занимаемое место выведенного числа; 2- колво знаков после запятой
			%3s   /* 3- колво взятых букв из строки



^Легенда:
	^		-глава
	/*		-комментарий
	...		-участок кода
	!..!	-уточненный участок
	@		-разобрано неполностью
	$$		-важные фичи
	ТД 		-тип данных



^Типы данных:															Спецификаторы форматов:
	Целые:
		short		-															%i, %d
		int			-															%i, %d, %o, %x
		long		-															%li, %ld
		long long	-															%lli, %lld
	Вещественные:
		float		-															%f, %A, %e, %E, %a, %F, %g, %G
		double		-															%lf, %lA, %le, %lE, %la, %lF, %lg, %lG
		long double	-															%Lf, %LA, %Le, %LE, %La, %LF, %Lg, %LG
	Символы:
		char		-															%c
		*char(стр)	-															%s

	unsigned:	/*Память под отрицательные числа добавляется к положительным	
		unsigned char 		-													%c 	        @
		unsigned short		-													%u
		unsigned int		-													%u
		unsigned long		-													%lu
		unsigned long long	-													%llu

	Неопределенный:
		void

	Указатель																	%p

	Абстрактные типы данных:
		struct !имя!
		enum !имя!
		union !имя!


	Занимаемое место(байт):
		char	-1
		int		-4
		float	-4
		double	-8

		adress	-8(64-разрядная) и 4(32-разрядная)

		enum	-4
		struct	-(зависит от полей)
		union	-(макс мальный размер одного из полей)



^Синтаксис:
	;			-конец строки кода
	, 			-перечисление

	Числовые типы (целых, вещественных):
		Унарные операции
			-
			(!ТД!) 			-смена типа
			++ 				/*до и после и для целых
			-- 				/*до и после и для целых
			& 	 			-адрес(+*) 
			*				-значение записанное по адресу(-*)
			~ 				-побитовое отрицание(0->1 1->0) 		/* -A = ~(A-1)
		Бинарные операции
			+, -, *
			/ 				-деление(для вещественных)
			% 				-остаток от деления(для целых)
			<, >, <=, >=, ==, != 	-операции отношения
			= 						-присваивание
			+=, -=, *=, /=, %= 		-составное присваивание
			
			& 			-побитовая конъюнкция
			| 			-побитовая дизъюнкция
			^ 			-побитовая XOR			/* если биты не равны то 1 иначе 0
			<<			-сдвиг влево			/* справа добавляется 0(все равно что *2)
			>>			-сдвиг вправо			/* слева добавляется 0 если число + и 1 если число -(все равно что //2)
			/* при сдвиге нужно учитывать занимаемое место битами
			/* если сдвиг k больше количества битов n то сдвиг = k%n
	Символьный тип:
		Унарные операции
			(!ТД!)
			&
		Бинарные операции
			< > <= >= == !=
			=

	Логическое «И» (&&) – бинарная операция
	Логическое «ИЛИ» (||) – бинарная операция
	Логическое «НЕ» (!) – унарная операция

	Приоритет операций:
		1.Постфиксный инкремент/декремент
		2.Логическое отрицание (!), унарный минус и приведение типа
		3.Умножение, деление, остаток
		4.Сложение и вычитание
		5.Сравнения(<, >, <=, >=).
		6.Логическое равенство и неравенство (== !=)
		7.Логическое «И»
		8.Логическое «ИЛИ»
		9.Тернарное условие
		10.Присваивание (получение значения)
		11.Составные арифметические операторы
		12.Оператор «запятая»



^Функции:
	1)Комментарии:
		//...					-однострочный комментарий
		/*...*/					-многострочный комментарий
	2)Константы:
		const !ТД! !имя!					-константа в пределах модуля(функции)
	  	#define !имя!	!значение!			-константа доступна для всех модулей
	  	enum !имя! {!названия и значения!}	-перечисление с целочисленными константами
	3)ТД:
		(!новый ТД!)!переменная!	-переменная поменяла тип
		/*Способ из символа цифры перевести в целочисленное число(48-код первой цифры)
		/* x = (int)x - 48

		sizeof(!ТД!)				-выделяемый объем памяти в байтах(целое число)	
		/*Вместо ТД можно любое выражение с переменными 
	4)Простой ввод и вывод в Си
		Ввод:
		– Отдельные символы
		с = getchar();
		– Числа различных типов и символы в одном операторе
		n=scanf("%d %lf %c", &a, &x, &c);
		(n — общее число прочитанных значений, соответствующих формату).

		Вывод:
		– Отдельные символы
		putchar(c);
		– Сообщения
		puts("Message for you");
		– Результаты вычислений
		printf("Results: %d %lf %c\n", a, x, c);
		или
		n=printf("Results: %d %lf %c\n", a, x, c);
		(n — общее число выведенных символов).
	5)Создание

	  !ТД! !имя переменной!						-создание переменной
	  /* !ТД! !имя переменной! = ..				-инициализация(создание + присваивание)
	  /* Если создать переменную вне ф-ций и до них, то она станет глобальной(НЕ РЕКОМЕНДУЕТСЯ)

	  !ТД! !имя массива![!кол-во элементов!]	-создание массива 				
	  !ТД! !имя функции!(){}					-создание функции

	  typedef !ТД! !имя ТД!						-создание удобного имени ТД
	6)Массивы:

		9.1)Создание

			!ТД! !имя массива![!кол-во элементов!]				-создание массива 
			!ТД! !имя массива![...][...]						-создание двумерного массива и тд  		

			/*ТД распространяется на каждую ячейку. В массиве все ячейки имеют один ТД		


		9.2)Заполнение

			!ТД! !имя массива![]={!значения!}				-инициализация  		
			!ТД! !имя массива![][]={{...},{...}}			-инициализация двумерного массива и тд	
			/*Если массиву сразу присвоить какие то значения их кол-во и будет размером массива
			/*Если при этом указать размер, а количество значений будет меньше, то остальные ячейки станут нулями

			A[!индекс!]	= !значение!		-смена значения в ячейке		
			/*Дефолтное значение ячеек рандомные числа

			A[x]							-x в 2-мерном массиве будет означать строку(A[x]-адрес строки, точнее 1го эл.)


			n*sizeof(!ТД!)								-объем памяти массива(n-кол-во ячеек)


			имя массива определяет адрес начала массива(&a[0] <=> a )
			=> массив в ф-цию передается всегда по ссылке(а значит ф-ция меняет сам массив)


			Типовые действия с массивом:
				Инициализация (установка значений элементов)
				Перестановка элементов (изменение порядка)
				Вычислительные действия с элементами массива
				Поиск элементов массива (частный случай — поиск максимального и минимального элементов)
				Копирование элементов массива
				Сортировка массива

			Чтобы задать массив через присваивание:				@
				Массив должен быть динамическим(иметь тип со *)
				Массив не скопируется а передастся в новый указатель(у одного массива два указателя) 


		9.2)Строки 		

			/*Массив символов, у которого последний элемент всегда — символ с кодом 0 ('\0').
			/*У массива всегда колво символов на один больше по сравнению со строкой из за нуля в конце

			""										-строка
			''										-символ

			char A[]="Hello World!"					-создание массива строки(1)		/*Для вывода использовать спецификатор формата %s
			char s1[]={'H','e','l','l','o','\0'}	-создание массива строки(2)

			puts("Hello");							-вывод строки(1)
			puts(!имя массива!);					-вывод строки(2)
			printf("Hello");						-вывод строки(3)
			printf("%s\n", !имя массива!);			-вывод строки(4)

			getchar() 								-ввод символа с клавиатуры(помогает избавиться от буфера)
			scanf("%s",!имя массива!)				-ввод строки	
			/*Нельзя привысить размер массива. Чтобы избежать ошибки нужно добавить к формату: %!колво символов!s
			/*Пробел считается как конец строки. Чтобы избежать неточности нужно изменить формат: %[^\n]

			/*Для ввода лучше создать свою функцию или использовать:

			fgets(!имя массива!, !макс длина!, stdin)	-получение строки с клавиатуры с контролем предельной длины
			/*Возвращает указатель на строку.
			/*Символ перевода строки (\n) тоже включается в строку! Чтобы отрезать этот перевод: !имя массива![!длина строки! - 1]='\0'
			/*stdin и stdout -указатели на специальные файлы, соответствующие «стандартным» устройствам ввода и вывода.

			strlen(s) — возвращает длину строки s («полезные» символы), тип int
			/*Необходима библиотека string.h

			Текст
			/*Массив строк. Т. е. двумерный массив, где каждая строка заканчивается переводом строки.

			Преобразование текста файла в массив

				Путь экономии памяти (проще, но дольше)
					Определяем количество строк в файле (пока fgets()!=NULL)
					Выделяем память для массива строк по счетчику строк
					Для каждой прочитанной строки определяем реальную длину,
					выделяем память и формируем элемент массива (strcpy()).

				Путь экономии времени
					Определяем количество байтов (символов) в файле
					Выделяем память под весь текст
					Считываем весь текст в большой массив (fread())
					Проходим по массиву и считаем символы перевода строки(абзацы)
					Выделяем память для массива строк по количеству абзацев
					Для каждого фрагмента текста (абзаца) считаем количество символов в абзаце, выделяем память для элемента массива строк и заполняем посимвольно элемент массива строк.

	7)Условный оператор:
		if(!условие!)						/*Фигурные скобки нужны если у нас больше 1ой строчки кода. Все условие пишем в скобках.
		{
			...
		}
		else if()
		{
			...
		}
		else
		{
			...
		}
	8)Циклы:

		С предусловием:
			while(!условие!)
			{
				...
			}

		С постусловием:
			do
			{
				...
			} while(!условие!);

		С параметром:
			for(!инициализация параметров!;!условие!;!изменение параметров!(выполняется после итерации))
			{
				...
			}

		11.1)break		-выход из цикла
		11.2)continue	-пропуск итерации

	9)Работа с функциями:

		/*Задача, решаемая в функции, должны быть простой.

		/*Назначение функций:
		/*	Устранение повторяющихся фрагментов кода
		/*	Многократное использование типовых фрагментов кода в разных программах
		/*	Упрощение чтения кода и сопровождения программы.

		/*Примеры задач для ф-ций:
		/*	Генерация массива N×M (для вещественных и для целых чисел)
		/*	Перестановка элементов массива (swap())
		/*	Сортировка (для выбранного алгоритма, направление сортировки
		/*	задается как дополнительный параметр)
		/*	Ввод массива
		/*	Вывод массива.

		1)Создание
			!ТД! !имя функции!(!параметры!)		-создание ф-ции
			{
				...
			}

				/*Функция в Си может не возвращать значение. Тогда она должна иметь тип void.
				/*Если функция возвращает значение, то тип функции должен соответствовать типу возвращаемого значения.

				/*Имена пользовательских функций не должны совпадать с ключевыми словами и именами библиотечных функций.

				/*Функция в Си может не иметь параметров или иметь переменное количество параметров (вариадические функции).
				/*Все переменные и параметры в ф-ции используются только в ней и никак не пересекаются с другими ф-циями(кроме указателей)

				/*Чтобы в параметрах был одномерный массив:
				/*!ТД! !имя массива![!размер!]
				/*!ТД! !имя массива![]
				/*!ТД! *!имя массива!

				/*Чтобы в параметрах был двумерный массив:
				/*!ТД! !имя массива![!размер!][!размер!]
				/*!ТД! !имя массива![][!размер!]
		2)Вызов
			!имя ф-ии!(!значение параметра(ов)!)		-вызов ф-ции

				/*Функция должна быть описана до ее вызова!
				Есть два варианта работы с ф-циями:
					Создавать ф-ции до главной main()
					Использовать прототип, а создавать после главной main()	(Прототип это создание без тела: !ТД! !имя функции!(!параметры!))
				Чтобы функция могла вызвать другую функцию, прототип вызываемой функции должен быть описан раньше прототипа  вызывающей.
				В прототипе имя параметров необязательно. Главное это типы и их порядок. 

				/*Если внутри пользовательской функции вызывается пользовательская функция с параметрами, 
				то параметры нужно передать из вызывающей программы во внешнюю функцию.

				/*Параметры при описании и при вызове функции должны совпадать по позициям и по типам.

				Передача параметров

					Передача по значению: содержимое аргумента копируется в
					формальный параметр функции. Изменения, сделанные в
					параметре, не влияют на значение переменной, используемой при
					вызове (что бы ни происходило с переменной внутри функции, в
					основной программе она имеет прежнее значение).
					
					Передача по ссылке: в функцию копируется адрес аргумента(&x). В
					теле функции этот адрес используется для доступа к значению
					аргумента, указанного при вызове. При этом изменения,
					сделанные в параметре функции, влияют на содержимое
					переменной, используемой при вызове.
					!ТД! !имя ф-ции!(int *a)	-пример прототипа
					!имя ф-ции!(&x)				-пример вызова

		3)return !значение!  - Функция приравнивается к этому значению(или даже функции) и останавливается.

			/*Подход структурного программирования — только один return !!! НО синтаксически допустимо несколько.

		4)exit()				-Выход с ошибкой		@


		5)Создание собственной библиотеки:

			Создаем файл (.h) и копируем все прототипы в него.
			Вызываем с помощью 			include "!имя файла!" 

			Создаем файл (.с) и копируем все описания функций кроме главной в него(но если Windows лучше этого не делать)
			Используем в проекте(если Windows)

		6)Указатели на функции(используется для функций высших порядков)

			/*Адрес функции является входной точкой в функцию. Указатель может использоваться вместо имени функции.
			/*Адрес функции получается при использовании имени функции без каких-либо скобок или аргументов (похоже на массивы).

			!ТД ф-ции!(*!имя параметра-функции!)(!типы и параметры!)			- создание параметра-функции
			/*В параметрах можно по желанию указать только ТД параметров
			/*В такой параметр можно вписать любую ф-цию(такого же типа) с одинаковым типом и кол-вом параметров



			!ТД ф-ций! (*!имя массива![!кол-во элементов!])(!типы и параметры!)			-создание массива указателей на функции

			!ТД ф-ций! (**!имя массива!)(!типы и параметры!)							-создание динамического массива указателей на ф-ции
			/*полезно с .h файлами

			/* Пример освобождения места в таком массиве
			(func-имя массива, long(**)(unsigned)-явное приведение типа массива, m-кол-во элементов, long(*)(unsigned)-тип указателя на ф-цию )

			func=(long(**)(unsigned))malloc(m*sizeof(long(*)(unsigned)))

			/* Пример создания и использование своего типа
			(calc-имя нового типа)

			typedef long(*calc)(unsigned)					-создание типа

			void convol(unsigned n, calc, long *res)		-прототип метафункции
			calc *func 										-создание динамического массива указателей на ф-ции
			func=(calc*)malloc(m*sizeof(calc))				-освобождение места

		7)Рекурсия

			/*Ее использование совсем необязательно. Можно использовать циклические операторы. Рекурсия менее эффективна, но красивее выглядит

			/*При рекурсии в функции должно быть условие, по достижению которого дальнейшего обращения не происходит.
			В условном операторе if должно быть две ветви:
			-рекурсивная(в которой находится повторение ф-ции)
			-граничная(которая заканчивает рекурсию и выдает результат)

		8)Вариадические ф-ции:
			/*Должна иметь хотя бы один явный параметр

			1)Создание:
				/*ставим троеточие в конце
				!ТД! !имя функции!(!явные параметры!, ...)		-создание ф-ции
				{
					...
				}

			2)Подходы формирования переменного списка:

				1. Конец списка - параметр-ограничитель
				2. Передача количества необязательных параметров дополнительным обязательным.

			3)Библиотека создания вариадических ф-ций:

				stdarg.h
					va_list !имя!											-спецпеременная
					va_start(!спецпер!, !последний явный параметр!) 		-установка указателя на первый неявный параметр
					va_arg(!спецпер!, !тип параметра!) 						-возвращает параметр и перемещает адрес на следующий
					va_end(!спецпер!)   	 								-закрывает список парматров


	10)Директивы:

		1)#define !имя!	!значение!	-константа доступна для всех модулей


		2)#include <...>				-подключает к программе указанный файл(в системых каталогах)	
		 	 #include "..."				-подключает к программе указанный файл(в текущем каталоге)		
	11)Работа с файлами:
		/*поток-файл



		Режимы доступа:

			"r"-			файл открывается для чтения с 0-го байта(Если его нет => указатель==NULL)
			"w"-			файл открывается для записи, ранее записанное теряется(Если его нет => создается и открывается для записи с 0-го байта)
			"a"-			файл открывается для записи в конец файла(Если его нет => создается и открывается для записи с 0-го байта)

			"r+"-			файл открывается для чтения и записи с 0-го байта(Если его нет => Runtime error)
			"w+"-			файл открывается для чтения и записи (перезаписи)(Если его нет => создается и открывается для чтения и записи с 0-го байта) 
			"a+"-			файл открывается для записи в конец файла(Если его нет => создается и открывается для записи с 0-го байта)

			/*От режимов с + лучше отказаться

		14.1)Создание

			FILE *!имя указателя на файл! 	-создание указателя на файл(ТД-FILE)
			/* stdout stdin stderr -потоки по умолчанию(три указателя на файлы), их не нужно создавать

		14.2)Открытие Закрытие файла

			!имя указателя на файл! = fopen(!имя файла!, !режим доступа!)		-открытие файла
			/* возвращает указатель типа FILE*, если поток удалось открыть
			/* возращает NULL, если произошла ошибка (При этом переменной errno будет присвоен код ошибки)
			/* файл должен находится там же где программа(если это не абсолютная ссылка)
		
			fclose(!имя указателя на файл!)										-закрытие файла
			/* возвращает 0, если поток данных и связанный с ним файл успешно закрыты
			/* возращает EOF (-1), если во время работы функции возникла ошибка. (При этом переменной errno будет присвоен код ошибки)

			/* значение errno определены в errno.h

		14.3)Ввод вывод в файле

			fgetc(!имя указателя на файл!)								-читает один символ (байт) из файла
			/* при достижении конца файла возвращает EOF. при ошибке чтения возвращает EOF и код ошибки в errno

			fgets(!имя массива!, !макс длина!, !имя указателя на файл!) – читает строку из файла, включая символ перевода строки (\n), но не более MAXLEN-1 символов.
			/* возвращает указатель на строку. После последнего прочитанного символа добавляется ´\0´.
			/* если достигнут конец файла, возвращает NULL.
			/* поскольку контролируется длина строки, можно использовать для ввода с клавиатуры (из stdin).
			/* переводит курсор в файле на следующую строку

			fputc(!символ!, !имя указателя на файл!) 	-записывает один символ в указанный файл. При ошибке записи возвращает EOF и код ошибки в errno.

			fputs(!строка!, !имя указателя на файл!) 	– пишет строку в указанный файл (включая stdout).
			/* если запись не удалась, возвращает EOF.
			/* длина строки не контролируется, т. к. строка уже кем-то сформирована.

			fscanf(!имя указателя на файл!, ...)
			fprintf(!имя указателя на файл!, ...)
			/* форматрный ввод и вывод в файле

			fwrite(!имя массива!, !размер блока!, !кол-во блоков!, !имя указателя на файл!)	-позволяет записывать в файл целиком массивы
			fread(!имя массива!, !размер блока!, !кол-во блоков!, !имя указателя на файл!)	-позволяет считывать из бинарного файла целиком массивы
			/* размер блока = кол-во байт в блоке
			/* файл получается не текстовый (бинарный, двоичный)
			/* возвращает число реально записанных блоков (можно контролировать). 

			ungets(!символ!, !имя указателя на файл!)	-возвращает только что прочитанный символ в поток (в большинстве случаев не имеет смысла).

		14.4)Курсор

			fseek(!имя указателя на файл!, !смещение!, !начало отсчета!) -позволяет установить текущую позицию в файле (в байтах)
			/* дальнейшее чтение (запись) пойдет с указанной позиции
			/* началом отсчета м.б. SEEK_SET (начало файла) или SEEK_END (конец файла)
			/* если ошибки нет, функция возвращает 0, иначе — errno.

			ftell(!имя указателя на файл!) 	-выводит разницу м/у предыдущей позицией курсора  и текущей(в байтах) в виде целого числа (long int) @
			/* в случае ошибки возвращает -1

			rewind(!имя указателя на файл!)	-возвращает "курсор" в начало файла

		14.5)Дополнительно

			!имя указателя на файл! = freopen(!имя файла!, !режим доступа!, stderr)	-перенапрвление вывода
			/* в данном случае перенаправление из stderr(где хранятся данные об ошибках) в наш файл 

			fileno()	-количество открытых файлов за время работы программы(возращает целое число)

			feof(!имя указателя на файл!)		-проверка окончания файла(возращает 0 если файл не закончился) 	@

	12)Структура, объединение, перечисление:
		/*Специальные ТД

		1)Структура:
			/*конструкция, которая позволяет объединять данные различных типов под одним именем.

			1)Создание типа:
				struct !имя структурного типа!
				{
					!ТД! !имя поля!;
					...
					!ТД! !имя поля!;
				}; 


				/* ;-обязательна в конце
				/* имя поля - переменная @
				/* Что может находится в полях структуры:
				/*	 Символы (char)
				/*	 Числа (short, int, long, float, double … )
				/*	 Массивы (одномерные и многомерные)
				/*	 Строки
				/*	 Структуры(кроме идентичных структур(не распространяется на указатели))
				/*	 Указатели на все перечисленное

				/* Если структура создана вне ф-ций и до них, то она становится глобальной для всех ф-ций
				/* Если структура создана в ф-ции, то она становится локальной для этой ф-ции


				typedef struct !имя структурного типа! !новое имя!	-переименование имени структуры

				typedef struct !имя структурного типа!				-создание + переименование структуры
				{
					...
				}!новое имя!;

			2)Создание переменной(или массива) структурного типа:

				struct !имя структурного типа! !имя переменной!;							-структура
				struct !имя структурного типа! !имя массива![!количество структур!];		-структуры
				struct !имя структурного типа! *!имя массива!;								-указатель на структуры(освободить место под все структуры)
				/*указатель на структуры = динамический массив структур

				struct !имя структурного типа! *!имя переменной!;	-указатель на структуру(освобождаем место под одну структуру)
				struct !имя структурного типа! **!имя переменной!;	-указатель на указатели структур

				/* Если структура переименована:
				/* !новое имя! !имя переменной!

				/*Для формирования массивов структур разумно использовать файлы.
				/*Каждая строка файла — элемент массива структур.
				/*Данные для полей разделяются каким-либо символом разделителем (не пробелом!)

				/* Для указателей нужно освободить место

				/*Для динамического массива:
				/*1. При динамическом выделении памяти требуется проверять успешность выделения.
				/*(При работе с файлами CSV можно посчитать количество строк, потом выделить память)
					n=0;
					while((fgets(s1,maxlen,df))!=NULL) n++;
					rewind(df);
					…
					arr=(struct sss*)malloc(n*sizeof(struct sss));

				/*2. Динамически выделенная память должна быть очищена, при выделении памяти не для всех элементов массива нужно очистить все 
				/*что было выделено.
				/*3. Если при очередном realloc() адрес массива стал NULL, то	очищать уже нечего.
			3)Создание(сразу) локальной переменной с локальным структурным типом создается внутри ф-ции:

					struct !имя структурного типа!
					{
						...
					}!имя переменной!; 

					/* (struct !имя структурного типа!) -является типом
					/* (!имя переменной!)				-имя структуры

					/* Анонимная структура пишется без !имя структурного типа!(используется только как локальный структурный тип без создания новых структур)

					/*Глобальная переменная структурного типа создается также но вне ф-ций и до них(НЕ РЕКОМЕНДУЕТСЯ) 
			4)Создание(сразу) массива структур:

				struct !имя структурного типа!
				{
					...
				}!имя массива структур![!количество структур!]; 

			5)Доступ к полям структуры:

				!имя структуры!.!имя поля!					-доступ к int, float, char ...
				!имя структуры!.!имя поля![!индекс!]		-доступ к массивам, строкам

				!имя массива структур![!индекс!].!имя поля!	-доступ к полям одной из структур в массиве 

				(*!имя структуры!).!имя поля!				-доступ к полям по указателю к структуре
				!имя структуры! -> !имя поля!				-удобный второй вариант

				(*!имя структуры![!индекс!]).!имя поля!				-доступ к полям по указателю к одной из структур в маассиве
				!имя структуры![!индекс!] -> !имя поля!				-удобный второй вариант



				/* Для доступа к полям вложенных структур:
				/* !имя структуры!.!имя поля!.!имя поля!. ...
			6)Операции со структурами:
				!имя структуры! = !имя другой структуры!						-структуры одного типа можно присваивать друг к другу @
				!имя структуры! = {значение поля 1, значение поля 2, ...}		-инициализация структуры(полей структуры)

				/*При динамических массивах в полях структуры:
				/*1. При описании структуры нельзя инициализировать указатели как NULL.
				/*2. Имеет смысл проверять результат выделения памяти для всех полей сразу.
				/*3. Нужно аккуратно обрабатывать ошибки выделения памяти и очистку памяти.

				/*Структура как параметр функции:
				/*1. В отличие от массива структуру как параметр функции можно передать по значению.
				/*2. Функция может вернуть структуру по имени (функция должна иметь соответствующий тип).
				/*3. Массив структур как параметр функции передается по ссылке.
				/*4. Объявление типа должно быть глобальным (вне функций), иначе для функции тип будет неизвестным.
				/*5. Если в полях структуры есть дин. массивы, то нужно передавать еще и длины этих массивов

			7)Упаковка структур:

				#pragma pack(1) — выравнивание по байтам(самая сильная упаковка)
				#pragma pack(2) — выравнивание по «словам»
				#pragma pack(4) — выравнивание по «двойным словам»

			8)Указатель на структуру:
				/*+: 
				/*1)скорость работы в ф-ции
				/*2)изменение самой структуры при передаче ее в качестве параметра(без указателя это можно сделать через присваивание)

				1. Указатель на структуру позволяет передать структуру в функцию с помощью вызова по ссылке.
				2. Когда функции передается только адрес структуры, то вызовы функции выполняются быстрее, 
				чем при передаче структуры целиком (не нужно разбирать структуру).
				3. Передача указателя позволяет функции модифицировать содержимое структуры, указанной в качестве фактического параметра.

				Синтаксис обращения к полям:
				либо (*stud0).name (*stud.name — указатель на поле а не содержимое поля по указателю).
				либо stud0 -> name 

				Для полей-указателей не нужно освобождать место в памяти(указателям присваивается массив, для которого уже освобождено место)
				Очистка структуры приведет к очистке всех полей(кроме указателей)
				Ф-ция может возращать указатель на структуру

			9)Списки(идентичная структура в структуре):

				1.9.1)Однонаправленный:
					/*Имеет ссылки на след. элементы

					/*ЛИНЕЙНЫЙ(L1)

					1)Создание

						1.1)"Голова" первый элемент:
							1. Определение структуры
							2. Определение и инициализация «головы»
							3. Инициализация элемента списка
								Определение и Инициализация 						
								Выделить Память 									
								Установить значение поля данных						
								Установить указатель next в NULL					
							4. «Привязка головы» к первому элементу списка			

								struct LNode
								{
									char data[32];
									struct LNode *next;
								};

								typedef struct LNode LN;


								LN *LHead=NULL;

								LN *p=NULL
								p=(LN*)malloc(sizeof(LN))
								strcpy(p->data,"dataword")
								p->next=NULL

								LHead=p

						1.2)Отдельная "голова":
							
							2.1)Создаем две структуры
								-
												cnt (счетчик элементов)
								struct LHead 	*first (указатель на первый элемент)
												*last (указатель на последний элемент)

												id (порядковый номер элемента)
								struct LNode	data (область данных элемента)
												*next (указатель на следующий элемент)

							2.2)Создание головы 										create_head()
								-Освобождение места
								-Инициализация полей

							2.3)Создание элемента списка								create_node()
								-Освобождение места
								-Инициализация полей

							2.4)Добавление первого элемента 							add_first()	
								-Изменение полей головы

							2.5)Добавление последнего элемента(не обязательно) 			add_last()
								-Изменение полей головы
								-Изменение ссылки предпоследнего элемента(первого)

					2)Добавление элемента списка:

						2.1)После														

							-После последнего 											if
								-Изменение ссылки последнего
								-Изменение полей головы
							-После не последнего 										else
								-Запоминаем ссылку на следующий в новом
								-Изменение ссылки не последнего
								-Изменение поля количества элементов головы

						2.2)Перед 														

							-Перед первым												if
								-Запоминаем ссылку в новом
								-Изменение полей головы
							-Перед не первым 											else
								-Запоминаем ссылку в новом
								-Изменение ссылки предыдущего
								-Изменение поля количества элементов головы
								или
								-Вставка "после" для предыдущего	

					3)Удаление элемента списка:

						-Первый
							-Изменение полей головы
							-Очищение ссылки и памяти

						-Последний
							-Найти предыдущий
							-Изменение last на предыдущий
							-Изменение ссылки предыдущего на ссылку следующего
							-Очищение ссылки и памяти

						-Середина
							-Найти предыдущий
							-Изменение ссылки предыдущего на ссылку следующего
							-Очищение ссылки и памяти

					4)Поиск элемента и длина списка:

						4.1)По номеру(позиции):	Начиная с первого элемента переходим по ссылкам n-1 раз
						4.2)По значению поля:	Начиная с первого элемента переходим по ссылкам пока не найдем нужный
						4.3)Длина списка:		Начиная с первого элемента переходим по ссылкам пока не NULL и накручиваем счетчик

					5)Сортировка:

						5.1)Перестановка элементов
						5.2)Создание массива указателей на структуры, сортировка массива и обратное преобразование

					/*КОЛЬЦЕВОЙ()
						/*В односвязном кольцевом списке:
						/*q=head→last; 
						/*q→next=head→first; 

						/*В кольцевом списке можно переставить head→first  и head→last на любые два соседних элемента («перемещение головы»).

						/*Особенности:
						/*● Проход по списку while(q!=NULL) ничего не дает. 
						/*Нужно либо while(q!=Head→first), либо использовать значение cnt из «головы» и цикл for().
						/*● При добавлении элемента перед первым в пустой список 
						/*поле next нового элемента должно содержать его собственный адрес
						/*(если список не пустой — все как в линейном списке).
						/*● При добавлении элемента после последнего в пустой список 
						/*поле next нового элемента должно содержать его собственный адрес, а если если список не пустой – адрес первого элемента
						/*(Head→first) .
						/*● При удалении элемента, если этот элемент является первым,
						/*необходимо изменить адрес, хранящийся в поле next последнего элемента кольцевого писка, 
						/*на адрес элемента, следующего за удаляемым.


				1.9.2)Двунаправленный:
					/*Имеет ссылки на след. и пред. элементы
					/*Особенности двусвязных списков:
						/*Можно перебирать элементы не только по next, но и по prev
						/*При удалении элемента нужно оперировать с next пред и с prev след
						/*При сортировке элементов нужно оперировать 4-мя указателями.

					/*ЛИНЕЙНЫЙ(L2)

					1)Создание

						1.1)"Голова" первый элемент:
							1. Определение структуры
							2. Определение и инициализация «головы»
							3. Инициализация элемента списка
								Определение и Инициализация 						
								Выделить Память 									
								Установить значение поля данных						
								Установить указатель next prev в NULL					
							4. «Привязка головы» к первому элементу списка			

						1.2)Отдельная "голова":
							
							2.1)Создаем две структуры
								-
												cnt (счетчик элементов)
								struct LHead 	*first (указатель на первый элемент)
												*last (указатель на последний элемент)

												id (порядковый номер элемента)
								struct LNode	data (область данных элемента)
												*prev (указатель на предыдущий элемент)
												*next (указатель на следующий элемент)

							2.2)Создание головы 										create_head()
								-Освобождение места
								-Инициализация полей

							2.3)Создание элемента списка								create_node()
								-Освобождение места
								-Инициализация полей

							2.4)Добавление первого элемента 							add_first()	
								-Изменение полей головы

							2.5)Добавление последнего элемента(не обязательно) 			add_last()
								-Изменение полей головы
								-Изменение ссылки на след последнего(первого)
								-Изменение ссылки на пред нового

					2)Добавление элемента списка:

						2.1)После														

							-После последнего 											if
								-Изменение ссылки на след последнего
								-Изменение ссылки на пред нового
								-Изменение полей головы
							-После не последнего 										else
								-Запоминаем след в новом в ссылке на след
								-Изменение ссылки на пред нового 
								-Изменение ссылки на пред след
								-Изменение ссылки на след не последнего
								-Изменение поля количества элементов головы

						2.2)Перед 														

							-Перед первым												if
								-Запоминаем первый в новом в ссылке на след
								-Изменение ссылки на пред первого
								-Изменение полей головы
							-Перед не первым 											else
								-Запоминаем не первого в новом в ссылке на след
								-Изменение ссылки на пред нового
								-Изменение ссылки на след предыдущего
								-Изменение ссылки на пред не первого
								-Изменение поля количества элементов головы
								или
								-Вставка "после" для предыдущего	

					3)Удаление элемента списка:

						-Первый
							-Изменение полей головы
							-Очищение ссылки и памяти

						-Последний
							-Найти предыдущий
							-Изменение last на предыдущий
							-Изменение ссылки предыдущего на ссылку следующего
							-Очищение ссылки и памяти

						-Середина
							-Найти предыдущий
							-Изменение ссылки предыдущего на ссылку следующего
							-Изменение ссылки на пред след на пред
							-Очищение ссылки и памяти @

					4)Поиск элемента и длина списка:

						4.1)По номеру(позиции):	Начиная с первого элемента переходим по ссылкам n-1 раз
						4.2)По значению поля:	Начиная с первого элемента переходим по ссылкам пока не найдем нужный
						4.3)Длина списка:		Начиная с первого элемента переходим по ссылкам пока не NULL и накручиваем счетчик

					5)Сортировка:

						5.1)Перестановка элементов
						5.2)Создание массива указателей на структуры, сортировка массива и обратное преобразование

					/*КОЛЬЦЕВОЙ()
						/*В односвязном кольцевом списке:
						/*q=head→last; 
						/*q→next=head→first; 

						/*В кольцевом списке можно переставить head→first  и head→last на любые два соседних элемента («перемещение головы»).

						/*Особенности:
						/*● Проход по списку while(q!=NULL) ничего не дает. 
						/*Нужно либо while(q!=Head→first), либо использовать значение cnt из «головы» и цикл for().
						/*● При добавлении элемента перед первым в пустой список 
						/*поле next нового элемента должно содержать его собственный адрес
						/*(если список не пустой — все как в линейном списке).
						/*● При добавлении элемента после последнего в пустой список 
						/*поле next нового элемента должно содержать его собственный адрес, а если если список не пустой – адрес первого элемента
						/*(Head→first) .
						/*● При удалении элемента, если этот элемент является первым,
						/*необходимо изменить адрес, хранящийся в поле next последнего элемента кольцевого писка, 
						/*на адрес элемента, следующего за удаляемым.
					/*1) В next последнего хранится адрес первого, а в поле prev первого – адрес последнего.
					/*2) При добавлении элемента в пустой список поля next и prev содержат адрес этого же элемента.
					/*3) При выводе элементов списка можно использовать циклы for() на основе значения поля cnt в «голове» списка.
					/*4) «Перемещение головы» также возможно.
			10)Стеки и очереди(на примерах списков):
				/*Новый элемент в списке добавляется перед первым

				1)Стеки:
					/*LIFO
					/*Взаимодействие через верхушку(top)
					/*top - первый элемент списка

						1)Добавление элемента(push)
							-new->next = *top
							-new->id   = ...
							-*top      = new
						2)Изъятие элемента(pop)
							-tmp=*top
							-*top=(*top)->next
							-return tmp
							-После работы ф-ции очистить элемент
						3)Доступ к элементу на «вершине»(peek) 
							-return top
							-Запомнить в переменную

						4)Длинна стека и поиск:
							4.1)По номеру(позиции):	Начиная с верхушки переходим по ссылкам n-1 раз
							4.2)По значению поля:	Начиная с верхушки переходим по ссылкам пока не найдем нужный
							4.3)Длинна
							-Если не в ф-ции запомнить верхушку
							-Начиная с верхушки переходим по ссылкам пока не NULL и накручиваем счетчик

						5)Очистка и удаление:

							1)Полная очистка -pop и очистка пока не NULL
							2)Удаление


				2)Очереди:
					/*FIFO
					/*Взаимодействие через начало и конец(qbegin qend)
					/*qbegin - последний элемент списка
					/*qend   - первый элемент списка

						1)Добавление элемента(put)
							-Пустая
							-Непустая
								-new->next=*qend
								(*qend)->prev=new
								(*qend)=new
								-Если был один элемент
									- (*qbegin)->prev=new
						2)Изъятие элемента (get)
							-tmp=*qbegin
							-*qbegin=(*qbegin)->prev
							-Если qbegin не NULL
								-(*qbegin)->next=NULL
							-Иначе
								-*qend=NULL
						/*Используя с рекурсией можно 
						/*полностью удалить или заполнить как нужно очередь одним вызовом ф-ции
						
						3)Доступ к началу очереди
							-return qbegin
							-Запомнить в переменную

						4)Длинна очереди и поиск:
							4.1)По номеру(позиции):	Начиная с конца переходим по ссылкам n-1 раз
							4.2)По значению поля:	Начиная с конца переходим по ссылкам пока не найдем нужный
							4.3)Длинна
							-Если не в ф-ции запомнить конец
							-Начиная с конца переходим по ссылкам пока не NULL и накручиваем счетчик

						5)Очистка и удаление:

							1)Полная очистка -get и очистка пока не NULL
							2)Удаление

			11)Битовые поля в структуре и Объединения:

				1)Битовые поля:
					struct !имя структурного типа!
					{
						!ТД! !имя поля!:!кол-во бит!;
						...
						!ТД! !имя поля!:!кол-во бит!;
					}; 

					/*Заполнение справа налево
					/*Если указать кол-во бит = 0 заполняться биты до размера приведенного типа
					/*Адрес битового поля получить нельзя

				2)Объединение:
					/*Структура но поля с меньшим размером заполняются в максимальном поле
					/*Заполнение справа
					/*Каждое поле использует фрагмент битового представления максимального поля

					union !имя! 							-для двоичиного представления ТД 
					{
						!ТД! !имя!;
						struct
						{
							unsigned !ТД! !имя поля!:1;
							...
							unsigned !ТД! !имя поля!:1;
						} !имя!; 
					}

		2)Перечисление:
			/*набор целочисленных значений, можно использовать вместо #define как константы

			2.1)Создание

				enum !имя! {!названия и значения!}

				/*После создания нельзя использовать названия для чего то другого, они уже заняты, по ним и идет обращение к элементам перечисления

				/*При этом если не задать значения то, первое значение =0, последующие на 1 больше предыдущего 
				/*Если задать то, начиная с заданного все последующие на 1 больше предыдущего

				/*Значение можно задавать через выражение, главное чтобы тип оставался целочисленным

			2.2)Создание переменной перечисляемого типа

				enum !имя перечисления! !имя переменной!;

				/* Если перечисление переименовано:
				/* !новое имя! !имя переменной!

			2.3)Создание переменной сразу

				enum !имя перечисляемого типа!
				{
					...
				}!имя переменной!; 



^Особенности:@
	0)	int main()		-главная функция(которая должна вернуть 0)
		{
			...
			return 0;
		}

		/*Для функции main() вызывающей программой является операционная система.


	1)У операции присваивания тоже есть результат. Он равен значению левого операнда.

	2)В Си любое ненулевое значение может интерпретироваться как «истина», а 0 — как «ложь».

	3)!выражение! ?!действие1!:!действие2! –тернарный оператор

	4)Унарные операции для целых чисел: изменение значения на 1.
		Префиксная форма:
			++i (или --i)
		Постфиксная форма:
			i++ (или i--)
		Для префиксной формы значение переменной сначала изменяется, затем используется в выражении.
		Для постфиксной формы значение переменной сначала используется в выражении, а затем изменяется.

	5)Если типы операндов различные, происходит приведение к наивысшему типу («повышение типа»).
	Приоритет типов:
	long double > double > float > unsigned long > long long > long >
	(unsigned int< - unsigned short <- unsigned char) > (int <- short <-
	char).

	6)Порядок разработки программы
		I. Постановка задачи: что дано, что требуется получить, какие преобразования
		входных данных нужно выполнить (проверки, расчеты и т. п.), какие нужны
		дополнительные сведения и предположения.
		II.Разработка алгоритма
		III.Разработка тестовых (контрольных) примеров. Тесты должны позволять
		проверить все варианты, имеющиеся в алгоритме
		IV.Тестирование алгоритма по примерам (трассировка) — какие значения
		принимают переменные на каждом шаге алгоритма
		V.Написание программы
		VI.Отладка программы – поиск ошибок
	7)Ошибки в программе
		I. Синтаксические ошибки (ошибки в написании операторов) – обнаруживаются
		компилятором. Пока не устранены эти ошибки, программа не заработает.
		II.Логические ошибки (ошибки в алгоритме) — обнаруживаются при тестировании
		алгоритма и программы с помощью контрольных примеров. При наличии таких
		ошибок программа работает, но неправильно.
		III.Ошибки времени выполнения (сбои и «зависания») — обнаруживаются при
		некоторых комбинациях данных или при определенных условиях запуска
		программы. Самый плохой вариант ошибок. Для устранения требуется
		тщательное изучение кода, тестирование более чем в одной операционной
		системе (и, возможно, более чем с одним компилятором).

	8)Переменная одного типа должна оперировать с переменными ее же типа(Не всегда обязательно)

	9)Числа с заданными основаниями: 

		0	-восьмиричное основание
		0x 	-шестнадцатиричное основание

	10)Динамическая память:


		Stack 			-Статические локальные переменные, указатели(создание переменных)
		Heap 			-Динамические переменные(прямые указатели на объекты)

		/*    int *p1, *p2;
			  int value;

			  p1=(int*)malloc(sizeof(int));
			  *p1=123;		-heap									
			  value=456;
			  p2=&value;	-stack 			*/




		malloc(), calloc() – выделение памяти
		realloc() – изменение размера выделенной памяти.

		Для этих функций тип возвращаемого значения не определен (void*), поэтому требуется явное приведение типа.
		Всегда требуется проверка успешности выделения памяти.

		if((p1=(int*)malloc(sizeof(int)))!=NULL)
		{
		<работаем>
		}
		else puts("Error at memory allocation");

		free(p) — очистка динамически выделенной памяти – обязательно, автоматически не делается!(+ p=NULL - очистка адреса)
		**p 		/*   **-stack aderess of heap adress

		Создание одномерного массива:

			1) Запрашиваем количество элементов
			2) Выделяем память динамически (calloc() или malloc()) в
			соответствии с типом элементов
			3) Если память успешно выделена (функция вернула не NULL), то
			работаем, по окончании работы очищаем память и сбрасываем
			указатель в NULL.
			4) Если память не выделилась, выдаем сообщение.

			Если в процессе работы требуется изменить размер массива,
			используется realloc(). При увеличении размера — проверяем на
			успешность выделения памяти (см. п. 3). При уменьшении размера
			— не проверяем (нет необходимости).

		Создание двумерного массива:

			1) Выделяем память для массива указателей, если успешно — то
			2) Выделяем память для указателей на строки, если успешно, то
			работаем. Иначе очищаем память, выделенную ранее для строк,
			очищаем память массива указателей, завершаем работу
			3) При удачном выделении — работаем, потом очищаем память,
			выделенную для строк, очищаем память массива указателей,
			завершаем работу.

			Двумерный массив «разворачивается» в куче в одну строку →
			строки двумерного массива не обязаны быть одинаковой длины!

			int *y;
			Тогда возможны присваивания y=x[0] или y=x[1] (адрес первого
			элемента первой или второй строки, куда-то записывается)
			int **z;
			z — адрес какого-то из вариантов y.


			int *y[2];
			y — массив из двух указателей
			Первый элемент — указатель на начало первой строки массива х,
			второй элемент — указатель на начало второй строки массива x.
			int **z;
			z — адрес массива y.

			Если двойной адрес(z) указывет на адрес первой строки или на адрес всего массива, то с помощью него можно обращаться к любому элементу массива т к(Двумерный массив «разворачивается» в куче в одну строку)



	11)Указатели(адреса):		(целое шестнадцатиричное число)

		/*	!!!При присваиваниях указателей: указатель слева - ссылка, указатель справа - конечный адрес!!!

		!ТД! *!имя!			-создание указателя-переменной(*-превращает переменную в указатель; **-адрес адреса)
		/* ТД должен соответствовать тому на что указывает адрес
		/* при добавлении * перед именем адреса мы получим значение записанное в нем(не при создании указателя)

		%p 							-спецфикатор адресов

		адрес массива это адрес первого его элемента
		&a[0] <=> a 		/*"a" без "&" т к имя массива сразу отсылает к адресу	
		&a[1] <=> a+1 
		&a[2] <=> a+2



		NULL 						-указатель который никуда не указывает

		Операции:
			Инициализация
				Пусть есть int *p;
				1. Можно дать p значение корректного адреса памяти
				p=(int*)0x7ffd653b09ac;
				Для этого нужно знать, какие адреса могут быть корректными.
				2. Если описаны переменные, то для них уже память выделена. Тогда
				указателю можно присвоить адрес переменной или другой указатель
				float f, *pF, *pG;
				pF=&f;
				pG=pF; /* pF и pG содержат один и тот же адрес */
				3. Запросить выделение памяти для указателя
				float *pF;
				pF=malloc(sizeof(float));
			Присваивание
			Сравнение(только для одного типа)
			Добавление числа 					/*адрес изменяется в соответствии с занимаемым местом типа данных
			Сложение и вычитание числа
				В операции могут участвовать указатель и величина типа int. При этом
				результатом операции будет указатель на исходный тип, а его значение
				будет на указанное число элементов больше или меньше исходного.
				int *ptr1, *ptr2, a[10];
				int i=2;
				ptr1=a+(i+4); /* равно адресу элемента a[6] */
				ptr2=ptr1-i; /* равно адресу элемента a[4] */

			Вычитание указателей
				В операции могут участвовать два указателя на один и тот же тип.
				Результат такой операции имеет тип int и равен числу элементов
				исходного типа между уменьшаемым и вычитаемым, причем если
				первый адрес младше, то результат имеет отрицательное значение.
				int *ptr1, *ptr2, a[10];
				int i;
				ptr1=a+4;
				ptr2=a+9;
				i=ptr1-ptr2; /* равно -5 */
				i=ptr2-ptr1; /* равно 5 */
			Инкремент и декремент

			Индексация
				Указатель может индексироваться применением к нему операции индексации, обозначаемой в Си квадратными скобками [ ]. 
				Индексация указателя имеет вид <указатель>[<индекс>], где <индекс> записывается целочисленным выражением.
				Возвращаемым значением операции индексации является данное, находящееся по адресу, смещенному в бóльшую или меньшую сторону относительно адреса, содержащегося в указателе в момент применения операции. 
				Этот адрес определяется так: (адрес в указателе) + (значение <индекс>) * sizeof(<тип>), где <тип> – это тип указателя.




			Косвенная адресация(&-получение адреса переменной)
			Преобразование типа((type*)  *-специально для адресов, **-для адресов адресов)

		Что нельзя делать (недопустимые операции):
			Сложение двух указателей
			Вычитание двух указателей на различные объекты
			Сложение указателей с вещественными числами
			Вычитание вещественных чисел из указателей
			Умножение указателей
			Деление указателей
			Поразрядные (битовые) операции



^Библиотеки:
	stdio.h:
		printf()	-вывести в соответствии с форматом(вывод переменных)
		scanf()		-ввести в соответствии с форматом(ввод переменных)
		getchar()	-ввести символ
		putchar()	-вывести символ(переменную)
		puts()		-вывести строку				/*выводится автоматическм в отдельную строку(то есть перевод строки до и после)

		fgets(!имя массива!, !макс длина!, stdin)	-получение строки с клавиатуры с контролем предельной длины

		sprintf(!массив!, !формат!, !переменные!) 	–создает строку из значений переменных представляемых в соответствии с форматом 
		sscanf(!массив!, !формат!, !переменные!) 	–делит строку, указанную в первом аргументе, на переменные, которые задаются строкой формата

		gets()		-ЗАПРЕЩЕНО

	stdlib.h:
		system()	-

		malloc(!кол-во байт!)							-выделяет память под указатель и возвращает сам указатель
		calloc(!кол-во элементов!, !место под элемент!)	-также выделяет память(+добавляет в пустые ячейки 0)
		realloc(!адрес!, !кол-во байт!)					-изменение размера выделенной памяти	/*Стараться применять редко $$

		free(!адрес!)			-освобождает память 			/*Очень важно ее постоянно применять, но осторожно	$$

		rand()					-возвращает рандомное число
		srand()					-стартовая позиция rand()

		qsort()					-быстрая сортировка(Алгоритм Хоара)

		atoi()					–преобразуют набор символов-цифр в числа(int) 		/*работают со строкой а не с символом
		atof() 					–преобразуют набор символов-цифр в числа(float)		/*работают со строкой а не с символом

	stdarg.h:
		va_list  	-тип
		
		va_start
		va_arg
		va_end

	string.h:
		strlen(s)				— длина строки s («полезные» символы), тип int
		strcmp(s1,s2)			— сравнение строк «как в словаре» (лексикографическое), тип int
		strncmp(s1,s2,n)		— лексикографическое сравнение первых n байт, тип int
		strcpy(s1,s2)			— копирование s2 в s1, тип «строка» (char*)
		strncpy(s1,s2,n)		— копирование n байт из s2 в s1, тип «строка»(автоматом добавляет '\0' в конце массива)
		memcpy(s1,s2,n)			— копирование n байт из s2 в s1, тип void*.(Для любых массивов)
		strstr() 				- определяет позицию первого вхождения подстроки в строку
		strcat() 				- дописывает новую строку в конец строки

	ctype.h:
		isalpha()		-возвращает ненулевое значение (true), если её аргумент является буквой, в противном случае возвращается нуль (false)
		isdigit()		-возвращает ненулевое значение (true), если её аргумент является десятичной цифрой, в противном случае возвращается нуль (false)
		ispunct()		-возвращает ненулевое значение (true), если её аргумент является знаком препинания (любой печатаемый символ, отличный от пробела или алфавитно-цифрового символа), в противном случае возвращается нуль (false).
		isupper(), islower() –проверяют регистр символов (не 0, если «да»)
		toupper(), tolower() –преобразуют регистр символов

	time.h:
		time(NULL)				-возвращает текущее время системы

	math.h:
		acos
		asin
		atan
		atan2
		atof
		ceil
		cos
		cosh
		exp
		fabs
		floor
		fmod
		frexp
		ldexp
		log
		log10
		modf
		pow
		sin
		sinh
		sqrt
		tan
		tanh

	limits.h:

	float.h:

	errno.h:
		perror(!строка перед ошибкой!)				-возращает имя ошибки
		errno										-код ошибки содержится в этой переменной



^Алгоритмы:
	
	1)Массивы

		1.1)Создание одномерного массива и заполнение своими значениями(x-колво ячеек в массиве; i-индекс ячейки)

			int x,i;
			int *A;		/* int, float, ..*/

			printf("Enter size array:");    
			scanf("%i", &x);

			if((A=(int*)malloc(x*sizeof(int)))!=NULL)		/* int, float, ..*/
			{
				puts("Enter numbers:\n");
				for(i=0; i<x; i++)
			    {
			    	scanf("%i", &A[i]);
			    }

			    for(i=0; i<x; i++)                          /* output array */
			    {
			    	printf("%i ", A[i]);
			    }

			    free(A);
			    A=NULL;
			}
			else puts("Error");


		1.2)Создание прямоугольного двумерного массива и заполнение своими значениями(n*k-колво ячеек в массиве; i,j-индекс ячейки)

			int n,k,i,j;
			double **A;				/* int, float, ..*/

			scanf("%i %i", &n, &k);

			if((A=(double**)malloc(n*sizeof(double*)))!=NULL)			/* int, float, ..*/
			{
				for(i=0; i<n; i++)
			    {
			    	if((A[i]=(double*)malloc(k*sizeof(double)))!=NULL)	/* int, float, ..*/
			    	{
			    		for(j=0;j<k;j++)
				    	{
				    		scanf("%lf", &A[i][j]);
				    	}
			    	}
			    	else puts("Error");
			    }

				for(i=0;i<n;i++)										/* output array */
				{
					for(j=0;j<k;j++)
					{
						printf("%lf", A[i][j]);
					}
					printf("\n");
				}

				for(i=0;i<n;i++)
		        {
		       	   free(A[i]);
		           A[i]=NULL;
		        }
		        free(A);
		        A=NULL;
			}
			else puts("Error");

		1.3)Создание массива без динамической памяти

			#define N ..

			...

			int A[N]

			...


		1.4)Удаление(ленивое) элементов по условию с заданного индекса(i-колво элементов в массиве; k-стартовый индекс; s-параметр цикла смещения)


		while(i>k)						

		{
			if(!Условие удаления!)
			{
				s=k;
				while (s!=i-1)
				{
					A[s]=A[s+1];
					s++;
				}
				A=(int*)realloc(A, (i-1)*sizeof(int))
				i--;
			}
			else
				k++;
		}

		1.5)Создание и заполнение рандомными числами(amax-максимально возможное число массива, x-колво ячеек в массиве; i-индекс ячейки )
		Необходимо подключить <time.h> <stdlib.h>

			int x,i,amax;
			int *A;		/* int, float, ..*/

			printf("Enter size array:");    
			scanf("%i", &x);

			printf("Enter max:");
			scanf("%i", &amax);

			if((A=(int*)malloc(x*sizeof(int)))!=NULL)		/* int, float, ..*/
			{
				puts("");
				srand(time(NULL));
				for(i=0; i<x; i++)
			    {
			    	A[i]=(int)(amax*((float)rand()/(RAND_MAX-1)));
			    }

			    for(i=0; i<x; i++)                          /* output array */
			    {
			    	printf("%i ", A[i]);
			    }
			}
			else puts("Error");

	2)Сортировка в массиве:

		2.1)Сортировка пузырьком(возр)	@(Не работает сверить с его алгоритмом)

			for(i=0;i<n;i++)
			{
				tmp=a[i];
				for(j=i-1; (j>=0)&&(a[j]>tmp); j--)  
				{
					a[j+1]=a[j];
				}
				a[j+1]=tmp;
			}

		2.2)Сортировка пузырьком(убыв)
		    for(i=0; i<n; i++)
    		{
        		for(j=0; j<n-1;j++)
        		{
            		if(a[j]<a[j+1])
            		{
                		tmp=a[j];
                		a[j]=a[j+1];
                		a[j+1]=tmp;
            		}
        		}
    		}

		2.2)Функция быстрой сортировки + смена значений(arr-массив,b-первый индекс,e-последний индекс)

			void my_qsort(int *arr,int b,int e)
			{
				int left,right,middle;
				left=b;
				right=e;
				middle=arr[(left + right)/2];
				while(left<=right)
				{
					while(arr[left]<middle) left++;
					while(arr[right]>middle) right--;
					if(left<=right) swap(&arr[left++],&arr[right--]);
				}
				if(b<right) my_qsort(arr,b,right);
				if(e>left) my_qsort(arr,left,e);
			}

			void swap(int *a, int *b)
			{
				int c;
				c=*a;
				*a=*b;
				*b=c;
			}

		2.3)Вызов функции быстрой сортировки из библиотеки(a-массив, m-количество элементов, sizeof(int)-занимаемое место элементом,cmp-функция)

			int cmp(int *a, int *b)
			{
				return *a-*b
			}

			qsort(a,m,sizeof(int),(int(*)(const void*,const void*))cmp);

	3)Строки

		2.1)Функция ввода строки

			void new_gets(char *s, int lim)
			{
				char c;
				int i;
				i=0;
				while(((c=getchar())!='\n')&&(i<lim-1))
				{
					s[i]=c;
					i++;
				}
				s[i]='\0'; 
			}

		2.2)Ввод текста

			char **str1=NULL;
		    char *s1=NULL;
		    int i,n,n1;

		    printf("Enter number of strings: ");
		    scanf("%d", &n);

		    if((str1=(char**)malloc(n*sizeof(char*)))!=NULL)
		    {

		        printf("\nPlease enter strings\n");
		        getchar();

		        for(i=0;i<n;i++) // filling array
		        {
		            printf("String %d: ",i);
		            if((s1=(char*)malloc(MAXLEN*sizeof(char)))!=NULL)
		            {
		                fgets(s1,MAXLEN,stdin);
		                n1=strlen(s1);
		                s1[n1-1]='\0';

		                if((str1[i]=(char*)malloc(n1*sizeof(char)))!=NULL)
		                {
		                    strncpy(str1[i],s1,n1-1);
		                    free(s1);
		                    s1=NULL;
		                }
		                else printf("Error at allocation string in array!!\n");

		            }
		            else puts("Fail at string allocation!");
		        }

		        printf("\nResults of processing\n");
		        for(i=0;i<n;i++)
		        {
		            printf("String %d \"%s\"\n",i,str1[i]);
		            free(str1[i]);
		            str1[i]=NULL;
		        }

		        free(str1);
		        str1=NULL;
		    }
		    else printf("Error at memory allocation!\n");

		2.3)Ввод строки

			char *s1=NULL;
		    int slen;

		    if((s1=(char*)malloc(MAXLEN*sizeof(char)))!=NULL)
		    {
		        printf("Enter your string: ");
		        fgets(s1,MAXLEN,stdin);
		        slen=strlen(s1);
		        s1[slen-1]='\0';
		        
		        printf("\nString \"%s\"\n",s1);

		        free(s1);
		        s1=NULL;
		    }
		    else puts("Error at memory allocation!");

	4)Структура для файлов(текстовых)

		char str[MAXLEN];
	    FILE *df;

	    if((df=fopen("data0.txt","r"))!=NULL)
	    {
	        printf("File content: \n");
	        while(fgets(str,MAXLEN,df)!=NULL) printf("%s", str);

	        if(fclose(df)!=EOF) printf("Closing OK\n");
	        else printf("Closing error code: %d\n", errno);
	    }
	    else perror("Data error");



?)Остальное

	?.1)Условная компиляция(очистка консоли)	(CLS-команда очистки; если не винда то закомментируем первою строку)

	#define OS_TYPE windows
	#ifdef OS_TYPE
	#def CLS system("cls")
	#else 
	#define CLS system("clear")
	#endif

	?.2)Создание меню ф-ций([option-1]	-индекс для нужной функции в массиве)

    do
    {
        printf("Functions to calculate:\n");
        printf("1 - ...\n");
        printf("2 - ...\n");
        printf("3 - ....\n");
        printf("Enter your choice: ");

        scanf("%d",&option);
    } while((option<1)||(option>3));
	
_____________________________________________________________________________________________________________________________________________________________