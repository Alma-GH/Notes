C:\Forall\Pyhonfiles



Следует изучить:
	1).format()
	2).split()



^Легенда:
	^		-глава
	#		-комментарий
	..		-участок кода
	!..!	-уточненный участок
	@		-разобрано неполностью
	$$		-важные фичи



^Типы Данных:
	Вещественные	-float(+,-,*,/,срав)
	Целые			-int(+,-,*,//,%,**,срав)
	Строки 			-str(+,*,in,срав)
	Списки			-list(+,*,in) 		  	#Изменяемые(то есть при их изменении их id остается, это будет тот же объект)
	Кортежи			-tuple(+,*,in,срав)
	Множества		-set,frozenset(срав)	#set Изменяемые
	Словари 		-dict(срав)
	Логические		-bool
	Ничего 			-None @



^Синтаксис:
	Возвращают bool:
		> 			-больше
		>=			-больше или равно
		< 			-меньше
		<=			-меньше или равно
		!=			-не равно
		==			-равно

		is(not is)	-один и тот же объект ли
		in(not in)	-есть ли в наличии в массиве(для последовательностей)

		and		-конъюнкция
		or		-дизъюнкция
		not		-отрицание

	Для множеств:
		&			-пересечение
		|			-объединение
		-			-разность
		^			-симметричная разность

	Изменяют:
		=			-присваивание
		+; -; /; *	-типичные математические действия
		**			-степень
		//			-целая часть от деления(div)
		%			-остаток от деления(mod)

		+=; -=; /=; *=; //=; %=; **=; -сразу изменяют переменную соответсвующим знаку образом	#a = a+5 <=> a += 5.

	Побитовые операции:
		~ 			-побитовое отрицание 	# -A = ~(A-1)
		& 			-побитовая конъюнкция
		| 			-побитовая дизъюнкция
		^ 			-побитовая XOR			# если биты не равны то 1 иначе 0
		<<			-сдвиг влево			# справа добавляется 0(все равно что *2)
		>>			-сдвиг вправо			# слева добавляется 0 если число + и 1 если число -(все равно что //2)
											#!число! !направление сдвига! !колво разрядов сдвига!
		
	Приоритет операций:
		1)действия в скобках;
		2)возведение в степень справа налево;
		3)унарные операции;
		4)операции умножения и деления слева направо;
		5)операции сложения и вычитания слева направо. 



^Функции:
	1)Комментарии:
		#...		-однострочный
		''' ... ''' -многострочный
	2)Ввод/Вывод:
		print(..)							-вывод
		!переменная!=input(!комментарий!) 	-ввод    	#Тип данных по умолчанию string
	3)Базовые(ТД, создание, удаление):
		1)ТД:
			type(!объект!)	- возвращает тип данных объекта
	 		int(..)			- изменение типа данных на целые
	 		float(..)		- изменение типа данных на вещественные
	 		str(..)			- изменение типа данных на строки(+создание)
	 		list(..)		- изменение типа данных на список(+создание)
	 		tuple(..)		- изменение типа данных на кортеж(+создание)
	 		set(..)			- изменение типа данных на изменяемое множество(+создание)
	 		frozenset(..)	- изменение типа данных на неизменяемое множество(+создание)
	 		dict(..)		- изменение типа данных на словарь(+создание)
	 		bool(..)		- изменение типа данных на логические			
	 		# 0, 0.0, "", None, False  /  все остальное, True
	 	2)Создание:
	 		!имя переменной! = !значение!	-создание переменной
	 		!имя массива! 	 = [!значения!]	-создание списка
	 		def !имя ф-ии!(!параметры!):	-создание ф-ции
	 			... 
	 	3)Удаление/Пропуск:
	 		del !переменная!		-Удалить переменную  	#Может применяться к изменяемым итерируемым последовательностям(спискам)(элемент, срез)
			pass					-Ничего не сделать		#Чтобы делать проверки без прописывания тела функций.				$$

	4)Условный оператор
		4.1)
		if !условие!:
			...
			...
		elif !условие!: 		       			 #Иначе если. Доп условие(Отрицание всех условий сверху & уточнение)
			...
			...
		else:		                         	 #Иначе.(Отрицание всех условий сверху. Стоит только в конце)
			...

		4.2)... if !условие! else ...                #Короткая запись.Если одна строка. Работает только с else @Вроде

	5)Циклы

		5.1)
		while !условие!:
			...
			...
		else:									#Выполняется после всех итераций один раз,если break не был выполнен. Если цикл вообще не 											выполнялся то и else не выполнится.
			...

		5.2)
		for !переменная! in !область приравнивания переменной!: #Задается либо массивом, либо строкой(что является тоже массивом). Его 																можно вписать:вручную через запятую, с помощью range, подготовленным массивом.
			...
			...
		else:			         				 #Выполняется после всех итераций один раз,если break не был выполнен. Если цикл вообще не 			         						 выполнялся то и else не выполнится
			...

		5.3)range(start, stop, step)	-Вызов нужного порядка чисел
			[start; stop)     	        -интервал
			step-шаг			         			 #Бывает разным в зависимости от знака перед числом.

		5.4)
		break      	- выход из цикла
		continue 	-переход на следующую итерацию

		5.5)Генератор
		!выражение! for !параметр! in !область приравнивания!

			Генератор с уловием
		!выражение! for !параметр! in !область приравнивания! if !условие!

	6)Коллекции

		6.0)

			6.0.1)len(..)			-длина(колво ячеек)

			6.0.2)Перебор элементов с помощью  for in

			6.0.3)Вывод без скобок *!имя!


		6.1)Итерируемые(списки, строки, кортежи):

			Индексация n-символьной(ячеечной) строки(списка,кортежа):
			1)от 0(первый символ) до n-1(последний символ)
			2)от -n(первый символ) до -1(последний символ)

			6.1.1)s[!индекс символа!]			-взятие одного символа строки

			6.1.2)
			s[x:y:z]					-взятие символов начиная с x по y-1 c шагом z (можно выходить за пределы)
			#x и y могут быть пустыми, тогда они рассматриваются как бесконечности/ z будет рассматриваться как 1
			#Если шаг отрицательный то начало и конец меняются местами




		6.2)Списки:

			6.2.1)list(..)		-Создание списка(массива)					@

			6.2.2)
				A=[..]			-Вариант создания списка
				A=[]			-Пустой список

				B=A[:]			-Копирование списка(с поверхностным копированием, то есть например при изменении вложенного списка он изменится везде)
				#B=A не создание нового списка а новая ссылка на тот же объект

				A[x:y]=[..]			-Вставка вместо среза или элемента



			6.2.3)[!выражение! for !параметр! in !область приравнивания!]		-Генератор списков

			6.2.4)A=[1,2,3] 		*-выводит без скобок
				print(A)
				вывод:[1,2,3]

				print(*A)
				вывод:1 2 3

			6.2.5)map(f,A)					-Применяет функцию f(без скобок) ко всем элементам списка A

			6.2.6)sum()						-Сумма всех элементов списка

			6.2.7)max()						-Максимум списка

			6.2.8)min()						-Минимуму списка

			6.2.9)sorted()					-Сортирует и возвращает новый список

		 	6.2.10)del !элемент, срез!		-удаление из списка
		 		 A[x:y] = []				

	 	6.3)Строки:	#Тип данных только str 				#Не является коллекцией, но имеет схожий функционал @

		 	6.3.1)	a=".."				-Вариант создания строки
		 			a=""				-Пустая строка
					b=a 				-Копирование строки(на самом деле нет, но это не мешает)

			6.3.2)	ord(..)					-код символа
					chr(!код символа!)		-вызов символа

		6.4)Кортежи:

			6.4.1)t = a, b, c 			-Вариант создания кортежа
				  t = ()				-Пустой кортеж
				  t = a,				-Кортеж из одного элемента 	#Нужна запятая, а иначе это уже не кортеж

		6.5)Множества:	#Тип данных только неизменяемые 	#Не может быть два равных элемента

			6.5.1)	s={..}				-Вариант создания изменяемого множества
					s=set()				-Пустое множество(s={} будет словарем)

					s=frozen(..)		-Единственный вариант создания неизменяемого множества		

			6.5.2)Сравнение

			==		-Два множества равны если состоят из одних и тех же элементов
			>,<		-Проверка на подмножество

			6.5.3){!выражение! for !параметр! in !область приравнивания!}	-Генератор изменяемого множества

		6.6)Словари:	#Ключ неизменяемый и неповторяемый(не бывает два равных ключа), а значения любого типа

			6.6.1) d = {!ключ! : !знач!, ..} 	-Вариант создания словаря
				   d = {}						-Пустой словарь

				   d = {[(!ключ!, !знач!), ..]}	-Еще вариант создания словаря

			6.6.2) zip(!список ключей!, !список значений!) 	-Создает словарь из двух равновеликих списков

			6.6.3) d[!ключ!] 				-Получение значения по ключу
				   d[!ключ!] = !знач!		-Изменение значения по ключу
				   d[!новый ключ!] = !знач!	-Добавление элемента

			6.6.4) del d[!ключ!]			-Удаление элемента 		#Если ключа нет произойдет ошибка

			6.6.5) sorted(!словарь!)		-Рассортированный список из ключей словаря

			6.6.6) {!ключ! : !выражение! for !параметр! in !область приравнивания!} -Генератор словаря #В параметре обязан быть ключ(он всегда разный)

	7)Своя функция

		7.1)Создание:
			def !название ф-ии!(!параметр!):	#Скобки обязательны.Параметр ф-ии:та переменная(может быть и ф-ей) которая используется только в ф-ии
				...

		Параметр функции можно приравнять к чему-либо. Тогда это значение станет дефолтом параметра.

		7.2)Вызов функции-
		!название ф-ии!(!значение параметра!)	#Скобки обязательны. Значение параметра функции-то чему будет равна переменная только в функции.

		Нескольким параметрам можно передавать значения:

			-по порядку
			-по имени(Параметр функции можно приравнять к чему-либо)
			-используя оба варианта, но позиционные аргументы помещаются перед параметрами передаваемыми по имени.
			(При этом значения параметров в вызове функции можно приравнивать к чему-либо в любом порядке)

		7.3)return !Значение! - Функция приравнивается к этому значению(или даже функции) и останавливается.		#По дефолту функция = None.

		7.4)Внутри функции можно использовать переменные, объявленные вне этой функции.	#Глобальные переменные

			Если их приравнять к чему либо другому, то будет создана новая одоноименная локальная переменная.
			(Поэтому нужно быть осторожным при приравнии типа += итд)

			global !глобальная переменная!		-Для изменения самой глобальной переменной внутри функции без создания локальной
 	


 	9)Методы
 		!имя объекта!.!метод!(!параметры!)

	 	9.1)методы для строк и списков

	 		только для строк

	 			.find(f,x,y)			-возвращает индекс первого вхождения(f-то что мы ищем; [x,y)-промежуток поиска)
	 			.rfind(f,x,y)			-возвращает индекс последнего вхождения(если x или y не указан то они принимаются за конец и начало(+1))
	 			#Если не найдено то =-1

	 			.replace(x,y,c)			-заменяет подстроку "x" на подстроку "y" (c-количество замен начиная слева)
	 			.count(f,x,y)			-подсчитывает кол-во вхождений подстроки(f-то что считаем, [x,y)-промежуток счета)

	 			y.join(x)				-Разделяет элементы строки "x"  "y"-aми(если проделать со списком он станет строкой)


	 		только для списков

	 			.append(..)				-добавление к списку					@
	 			.insert()				-добавление к списку по индексу			#Сначала ячейка освобождается смещением, потом добаляется элемент
	 			.sort()					-сортирует список 						@
	 			.pop(!инд!)				-удаление одного элемента по индексу и возвращение его значения	#По дефолту берется последний индекс
	 			.remove(!знач!)			-удаление элемента по значению			@
	 			.clear()				-очищает список 						@
	 			

	 	9.2)методы для кортежей

	 			.index(!знач!, [x,y])	-возвращает индекс первого слева элемента нужного значения в промежутке
	 			.count(!знач!)			-возвращает количество элементов нужного значения

	 	9.3)методы для множеств

	 			.issubset(!множество!)				- < возвращение bool
	 			.issuperset(!подмножество!)			- > возвращение bool

	 			.discard(!знач!)					- удаление элемента 	#Элементу необязательно существовать. Ошибки не будет
	 			.add(!знач!)						- добавление элемента
	 			.remove(!знач!)						- удаление элемента 	#Элемент должен существовать. Иначе будет ошибка
	 			.copy()								- поверхностная копия 	@

	 			.intersection(!множество!)			- & возвращает новый объект
	 			.union(!множество!)					- | возвращает новый объект
	 			.difference(!множество!) 			- - возвращает новый объект
	 			.symmetric_difference(!множество!)	- ^ возвращает новый объект

	 			.intersection_update(!множество!)				- & возвращает измененный объект
	 			.union_update(!множество!)						- | возвращает измененный объект
	 			.difference_update(!множество!) 				- - возвращает измененный объект
	 			.symmetric_difference_update(!множество!)		- ^ возвращает измененный объект	 		

	 	9.4)методы для словарей

	 			.get(!ключ!, !знач!)			- получение значения по ключу
	 			#Преимущество перед стандартным получением в том что ошибки не возникает при отсутствии ключа, вместо этого выдаст второй параметр
	 			#По дефолту знач = None

	 			.keys()							- возвращает все ключи
	 			.values()						- возвращает все значения

	 			.items() 						- возвращает представление всех пар (кортежей) из ключей и значений		#Нужны две переменные

	 			.pop(!ключ!, !знач!)			- удаляет элемент по ключу и возвращает его значение, если ключ не найден возвращает второй параметр
	 			#Без второго параметра может возникнуть ошибка

	 			.clear()						-очищает словарь
	 			.copy()							-поверхностное копирование словаря

	 	9.5)методы для файлов

	 		.close()							-закрыть файл		
	 		.read(!кол-во символов!)			-считывает(возращает) содержимое из файла. При этом указатель перемещается по файлу(потоку)
	 		#Если не указать параметр то будет считан весь файл

	 		.readline()							-считывает одну строку из файла (до символа конца строки ‘\n’), 
	 											возвращается считанная строка вместе с символом ‘\n’. 
	 		#Если считывание не было успешно (достигнут конец файла), то возвращается пустая строка

	 		.write(!строка!)					-запись данных в файл
	 		.tell()								-возвращает текущую позицию указателя
	 		#В Windows '\n' обозначается двумя символами



	10)Работа с файлами


		10.1)!переменная! = open(!имя файла!, !режим доступа!)		-Ф-ция открытия файла(потока)	

			#Функция возвращает ссылку на файловый объект, которую нужно записать в переменную, 
			чтобы потом через данный объект использовать методы ввода-вывода. 
			#Возможна ошибка: если нет такого файла или нет доступа к нему
			#Оба параметра  : str
			#Потоки 		: текстовые и двоичные
			#Операции с потоками: чтение и запись
			#Успешное открытие файла установит текущую позицию в начало файла, и после последнего байта файла, если режим установлен на 'a'.

			Режимы доступа:	#Возможно объединение #По дефолту "rt"

				'r'	-открытие на чтение (является значением по умолчанию).
				'w'	-открытие на запись, содержимое файла удаляется, если файла не существует, создается новый.
				'x'	-открытие на запись, если файла не существует, иначе исключение.
				'a'	-открытие на дозапись, информация добавляется в конец файла.

				't'	-открытие в текстовом режиме (является значением по умолчанию).
				'b'	-открытие в двоичном режиме.
				
				'+'	-открытие на чтение и запись



		10.2)!переменная!.close() 									-Метод для закрытия файла и прекращения работы с ним


		10.3)Файлы итерируемы поэтому к ним применим цикл for in. При этом считывание построчное	#Работает при открытии на чтение



	11)Использование модулей:
		#Обычный файл c программным кодом, содержащий определения функций, классов и некоторых переменных
		#Импортируемый модуль может содержать программу не только на языке Python

		11.1)import !модуль!(имя файла без расширения)			-Импорт модуля(1ый способ)

			 import !модуль! as !псевдоним!						-Импорт модуля, но с удобным для вас названием, чтобы избежать конфликта имен
			 													 #При этом старое имя нельзя использовать

			#Как правило, все инструкции import помещаются в начало файлов, 
			лучше сначала импортировать стандартные модули, а затем модули сторонних разработчиков, потом свои собственные.			$$

			!модуль!.!имя функции!(!параметры!)					-использование функции из модуля

		11.2)from !модуль! import !функция!						-Импорт отдельных функций из модуля(2ой способ)

			 from !модуль! import !функция! as !псевдоним функции!, ... 		-Импорт отдельных функций из модуля, но с удобным для вас названием
			 																	#При этом старое имя можно использовать только как переменную
			 																	#Можно переименовать множество функций через запятую

			#Если вместо функции поставить *, будут импортированы все функции модуля.
			Для этого нужно знать все названия, тк иначе могут возникнуть конфликты имен

			!имя функции!(!параметры!)							-использование функции из модуля(2ым способом использование стандартное)

		11.3)dir(!модуль!)										-Список содержимого модуля в алфавитном порядке
																#Работает только после импорта соответствующего модуля



	12)Обработка исключений:

		12.1)Если в try ошибка то выполняется except

		try:
			...
		except !имя исключения!  as !переменная!@  :	#Исключение и переменная необязательны. По дефолту исключение = множество всехи исключений
			...
		#Можно продолжать except.
		#При построении такого каскада нужно начинать от более специализированных к более общим исключениям. Тк выполняется только один из них

		else:								#Необязателен. Не выполняется в случае возникновения исключения
			...
		fynally:							#Необязателен. Выполняется всегда
			...

		12.2)Вызов исключения(1)

		raise !имя исключения!(!параметр!)		

		#В параметре строка которая будет выведена на экран, если исключение не обрабатывается
		#Если исключение не указывается, то повторно возбуждается активное

		12.3)Вызов исключения(2)

		assert !выражение!

		#Если выражение ложно то происходит вызов исключения  AssertionError



^ООП:	
	#Класс - Тип данных
	#Экземпляр класса - Объект

	1)class !имя класса!:	-создание и заполнение класса
	2)"""..."""				-создание документации для класса

	3)!переменная!=!класс!()	-создание экземпляра класса
	#Экземпляр берет методы(функции) и атрибуты(данные) из своего класса

	4)!экземпляр!.!переменная!=!значение!	-создание локального атрибута
	#Если имя локального атрибута совпадает с атрибутами класса то экземпляр перестает ссылаться на этот атрибут 

	#Удалять атрибуты и экземпляры можно через del

	5)Методы:

		.__dict__		-набор локальных атрибутов экземпляра класса
		.__doc__		-строка с документацией класса
		.__name__		-строка с именем класса

	6)Функции:

		getattr(!экземпляр!, !имя атрибута!(str), !дефолт!)	-возращает значение атрибута объекта, если он не существует, то возращает дефолт
		hasattr(!экземпляр!, !имя атрибута!(str))			-возращает True, если существует такой атрибут, иначе False
		setattr(!экземпляр!, !имя атрибута!(str), !знач!)	-задает значение атрибута, если такой не существует - он создается
		delattr(!экземпляр!, !имя атрибута!(str))			-удаляет атрибут

		isinstance(!экземпляр!, !класс!)					-возращает True, если экземпляр принадлежит классу, иначе False



^Особенности:
	1)Переменной можно в любой момент присвоить нужный тип данных 		#Не обязательно сразу после ввода, она спокойно переведется из одного в другой.


	2) first = sec = third = 1 											# Всем трём переменным будет присвоено значение 1.
	   first, sec, third = "Hi", 75, 23.1								# Поочередное присвоение значений.

		2.2) a,b=b,a 													#Обмен значений переменных не используя третию

		2.3) a,b,*c=A 													
		#При присваиваивании нескольким переменным значения списка 
		кол-во элементов должно быть равно кол-ву ячеек списка или же должна использоваться *(переменная со звездочкой получит оставшийся список)

	3)При присваивании переменной значения, тип данных устанавливается автоматически(Duck typing).
	#Введешь число будет int или float, введешь слово будет str и т. д.
	4)Остаток в питоне всегда равен знаку делителя(округление в меньшую сторону)
	# Это значит:       -13//10=-2     -13%10=7
						-13//-10=1		-13%-10=-3
	5)Если в range() одно значение,  то start=0 step=1, a stop является этим значением.
	6)Булевые значения пишутся с заглавной буквы: False, True.
	7)Переменным можно присваивать True или False через выражение.	
	#flag=(x%10==0) то есть если х делится на 10 то flag=True, а если не делится flag=False

	8)Если не хватает строки то можно использовать скобки.
	#a=(5+3
	+4)
		8.1)Чтобы уместить в одной строке несколько, нужно после каждой "строки" ставить ";".
		#a=1; b=input(); print(a,b)		-все успешно сработает
	9)Удобная конструкция каскадного условного оператора:
	if ...:
		...
	elif ...:
		...
	elif ...:			#В последнем elif делать проверку. А в else выдавать ошибку. Чтобы своевременно исправлять ошибки в коде.	$$
		...
	else:
		...
	10)Перевод числа в другую систему счисления: 
	0b...-двоичная
	0o...-восьмиричная
	0x...-шестнадцатиричная
		10.1)Присваивание переменной числа с заданным основанием:
		a=int(str('!число!'), !основание!)
		base -основание 	#36 max.
		10.2)Возвращение числа с нужным основанием(2, 8, 16) строкой.
		bin(x)-в двоичной
		oct(x)-в восьмиричной
		hex(x)-в шестнадцатиричной
	11)Параметр конца ввода print:
	print(.., end='!то что будет в конце!')			#По дефолту Enter.
		11.2)Параметр отступа print:
		print(.., sep="")                               #В данном случае между значениями(то есть вместо запятых) будет ничего. По дефолту Space.
		11.3)Вывод Enter в строке -\n
	12)Переменной можно присвоить функцию.
		12.1)Параметр функции можно приравнять к чему-либо. Тогда это значение станет дефолтом.
		Пример:
		def function_test(a=5):
			print(a)
		function_test()
		#Напечатает- 5
		def function_test(a):
			print(a)
		function_test()
		#Будет ошибка	
		def function_test(a=5):
			print(a)
		function_test(4)
		#Напечатает- 4
		12.3)Значения параметров в вызове функции можно приравнивать к чему-либо в любом порядке.  @Разобрано не до конца
		Пример:
		def test(a, b, c):
			print(a, b, c)
		test(b=1, c=2, a=3)
		#Напечатает- 3 1 2
		def test(a, b, c):
			print(a, b, c)
		test(1, 2, 3)
		#Напечатает- 1 2 3

		12.4)Нельзя прописывать функцию после ее применения. Желательно их прописывать в самом начале кода.
		12.5)Для правильного использования функций нужно исплользовать "Проектирование "сверху-вниз""	
		#Вначале делается "чертеж", то есть мы придумываем несуществующие функции с параметрами, которые должны будут выполнить определенные задачи, а потом уже мы реализуем эти функции. Нужно отталкиваться от главной задачи, постепенно "снижаясь" к подзадачам			$$
		12.6)"""...""" или '''...'''		-Задать описание функции(Документ-строка) 	#Пишется внутри функции.				$$
		12.7)help(!название функции!)		-Выводит описание Функции 															$$

	13)Очень важно давать правильное название переменным и особенно функциям так, чтобы оно отражало их суть.				$$ 
	14)Строки тоже можно сравнивать. Сравнение как в словарике. Чем дальше от начала тем больше строка. 
	15)Возвращение типа данных 			-type(!Переменная у которой проверяем тип!)
	16)Заглаваная и маленькая буква будут являться различными переменными. 			#А и а -будут являться различными переменными.
	17)При выводе массива выводиться не каждый его элемент а сам массив со скобками. Чтобы отбирать именно его элементы нужно использовать цыкл for.
	#for i in A:			
		print(i)	Так мы выпишем все элементы массива А.

		17.1)Индексы в массиве начинаются с нуля(То есть индекс первого элемента =0, второго =1 и т.д.)

		17.2)Массив можно умножать на целое число. Тогда он размножит свои прошлые значения в нужное количество раз
		#A=[1,2,3,4.8,"Hi"]*2
		print(A*2)				Программа выведет:	[1, 2, 3, 4.8, 'Hi', 1, 2, 3, 4.8, 'Hi', 1, 2, 3, 4.8, 'Hi', 1, 2, 3, 4.8, 'Hi']

	18)Присваивание в Python это связывание  имени(переменной) и объекта.  (ссылочная модель данных) 
	#Если два имени ссылаются на один и тот же изменяемый объект(существуют изменяемые и неизменяемые(константы) объекты), то при изменении этого объекта обе переменные изменятся.
	Пример:
	A=[1,2]  или 	A=B=[1,2]
	B=A 			A[0]=2
	A[0]=2			print(B)
	print(B)							Выведет  -[2,2]

	a=1		или 	a=b=1
	b=a 			a=2
	a=2				print(b)
	print(b)							Выведет  -1 (т.к. используются константы)

	19)Операторы сравнения можно объединять в цепочки
	# 	a=4
		print(3<a<15)
		вывод:True

	20)s=''' 

	 		
	 	'''	-многострочная строка

		20.1)\\ -вывод одного слеша
			 \n -перевод на новую линию

		20.2)s=r"..." -неформатированная строка(то есть \n, \\ и т д не работают)

	21)A=[

	[..]
	[..]
	[..]

	] - многострочный двумерный массив

	21)Коллекции:

		Типы:
			Последовательности(+,*,индексация,срез)
				Списки
				Кортежи
				Строка @
			Множества
				Изменяемые(set)
				Неизменяемые(frozenset)
			Отображения
				Словари


		Изменяемые
			Списки
			Словари
			Множества set
		Неизменяемые
			Кортежи
			Множества frozenset

		Итерируемые(in(not in), for in)
			Списки
			Строки
			Кортежи
			Файлы

	22)Ошибки в Питоне

		Существуют три типа ошибок в программе:
			1.синтаксические – как правило, интерпретатор предупредит о наличии
			ошибки, а программа не будет выполняться совсем;
			2.логические – это ошибки в логике программы, которые можно выявить
			только по результатам ее работы, как правило, интерпретатор не
			предупреждает о наличии такой ошибки, выявить и исправить такие ошибки
			достаточно трудно;
			3.ошибки времени выполнения – это ошибки, которые возникают во
			время работы программы, причиной являются события, не
			предусмотренные программистом, классическим примером служит деление на ноль

		Иерархия встроенных классов исключений

			BaseException
			    GeneratorExit 
			    KeyboardInterrupt
			    SystemExit
			    Exception
			        StopIteration
			        Warning
			            BytesWarning 
			            DeprecationWarning, FutureWarning, ImportWarning
			            PendingDeprecationWarning, RuntimeWarning, SyntaxWarning
			            UnicodeWarning, UserWarning
			        StandardError
			            ArithmeticError
			                FloatingPointError, OverflowError, ZeroDivisionError
			            AssertionError
			            AttributeError
			            EnvironmentError
			                IOError
			                OSError
			                    WindowsError
			            EOFError
			            ImportError
			            LookupError
			                IndexError, KeyError
			            MemoryError
			            NameError
			                UnboundLocalError
			            ReferenceError
			            RuntimeError
			                NotImplementedError
			            SyntaxError
			                IndentationError
			                    TabError
			            SystemError
			            TypeError
			            ValueError
			                UnicodeError
			                    UnicodeDecodeError, UnicodeEncodeError
			                    UnicodeTranslateError



^Библиотеки:
	
	1)random 

		randint(a,b)			-возвращает рандомные числа от a до b

	2)copy

		copy(x) 		- возвращает поверхностную копию x.
		deepcopy(x)		- возвращает полную копию x.

	3)tkinter

		Tk()														-Окно
		Label(!Где!, text= , image= )								-Создание виджета
		Entry(!Где!, width= ,bg= ,fg= ,borderwidth= ,)				-Создание строки для записи

		Button(!Где!, text= ,state= ,padx= ,pady= ,command= ,fg= ,bg= )		-Создание кнопки
		#state=DISABLED чтобы отключить кнопку. command=!функция без скобок!, command=lambda: !функция со скобками! если нужны параметры. 
		fg-цвет текста, bg-цвет кнопки, принимают str, либо прямое название цвета либо код через знак #.

		

		.pack()														-Вставка
		.grid(row= ,column= ,columnspan= ,padx= ,pady= )			-Вставка по рядам и столбцам
		.grid_forget()												-Убрать
			Label
			Entry
			Button	
		
		.mainloop()													-Зациклить окно
		.title(!Текст!)												-Заголовок окна
		.quit()														-Закрыть окно
		.iconbitmap(!ссылка!)										-Иконка в заголовке			
			Tk

		.get()														-Вернуть строку из строки записи 
		.insert( ,!Текст!)											-Вставить текст в строку для записи
		.delete( ,END)												-Стереть
			Entry

	4)PIL

		ImageTk()
		Image()


		.PhotoImage()
			ImageTk
		.open(!ссылка!)
			Image



^Алгоритмы:
	1)Массивы	

		1.1)#Создание массива и заполнение своими значениями(k-колво ячеек в массиве; i-индекс ячейки)

			k=int(input())
			A=[0]*k
			for i in range(0,k,1):
				A[i]=int(input())

		1.2)#Создание массива в одной строке

			A=list(map(int, input().split()))

		1.3)#Создание двумерного прямоугольного массива(r-строк, с-столбцов)

			r,c = map(int, input().split())
			A = r*[0]
			for i in range(r):
				A[i] = [0]*c

		1.4)#Создание двумерного прямоугольного массива второй вариант(r-строк, с-столбцов)

			r,c = map(int, input().split())
			A = []
			for i in range(r):
				A.append([0]*c)

		1.5)#Создание двумерного прямоугольного массива третий вариант(r-строк, с-столбцов)

			r,c = map(int, input().split())
			A = [[0]*c for i in range(r)]



	2)Нахождение НОД(x-первое число; y-второе число)
		
		2.1)#Затрата большого времени, но легко понять(x и y-НОД)

			while x!=y:
				if x>y:
					x-=y
				else:
					y-=x

		2.2)#Эффективный способ, но сложнее понять(y-НОД)
		
			while x != 0:
				y, x = x, y % x


	3)Смена ключей и значений местами в словаре

		d2 = {y: x for x,y in d1.items()}

	4)Функция: Перевод в 10-ую систему счисления из n-ой (a-строка нужного числа; b-основание n)

		def switch_base10(a, b):

			k=-1
			for i in  a:
				if i==".":
					break
				k+=1

			res=0
			for i in a:
				if i!='.':
					res+=int(i)*b**k
					k-=1

			return res

______________________________________________________________________________________________________________________________________________________________


