Легенда:

	@ - глава
	% - параметр
	& - пример, имеет пример
	** - особенности
	? - неразобранно полностью, непонятно
	#...# - вставка //старое

	Сокращения:

	mod - модификаторы (static public)

Термины в C#:

	Поле - переменная-член класса
	Свойство - геттер и сеттер



@ Базовое:

	@ Типы переменных:

		Целочисленные:

			sbyte	-128:127
			short 	-32768:32767
			int 	-2147483648:2147483647
			long 	-9223372036854775808 : 9223372036854775807

			byte 	0:255
			ushort 	0:65535
			uint 	0:4294967295
			ulong 	0:18446744073709551615

		С плавающей точкой:

			float	- менее точный (4 байта)
			double	- более точный (8 байт)
			decimal - самый точный (16 байт)

		Ссылочные типы:

			object - базовый класс каждого типа в системе типов .NET (в том числе фундаментальных типов данных)

			string: "hello"


		char: 	'a'

			• В C# символы представлены 16-разрядным кодом (Unicode)
			• В C# отсутствует автоматическое преобразование символьных значений в целочисленные и обратно.

		bool: 	true

			• В C# не определено взаимное преобразование логических и целых значений. 1 не преобразуется в true, а 0, в значение false.

		var - тип определяется автоматически, и переменная должна быть инициализирована

	@ Преобразования:
	
		• Явное преобразование типов: (ТИП)ВЫРАЖЕНИЕ

		• Методы Convert (System) могут конвертировать одни типы данных в другие:
	
			Convert.ToInt32(%) 		- int
			Convert.ToDouble(%) 	- double
			Convert.ToDeciamal(%) 	- decimal

		• Неявное преобразование типов происходит автоматически при следующих условиях:
	
			-> оба типа совместимы
			-> диапазон представления чисел целевого типа шире, чем у исходного типа

		• Перехват сужающих преобразований данных:

			checked( АРИФМ. ОПЕРАЦИЯ )

			checked
			{
				АРИФМ. ОПЕРАЦИИ
			}

			& Пример:
	
				try
				{
					byte sum = checked( (byte)(150+250) ); //макс диапозон byte: 255
				}
				catch(OverflowException ex)
				{ ... }
	
			• Если оператор заключен в контекст checked, компилятор C# генерирует исключения, обеспечивающие проверку на предмет условий переполнения, которые могут возникать в результате сложения, умножения, вычитания или деления двух числовых типов данных
	
			• unchecked можно применять при наличии блока кода, в котором переполнение является допустимым

		• Расширающее преобразование - неявное преобразование
		• Сужающее преобразовние - явное преобразование

		• Дробные числа:

			• Арифмитические операции с дробными числами никогда не вызывают переполнения

			• Дробные числа могут принимать специальные значения, при ошибках: Infinity и NaN

			• Проверить имеют ли дробные числа эти значения вызываем функции: double.IsInfinity( ПЕРЕМЕННАЯ )double.IsNaN( ПЕРЕМЕННАЯ )

			• decimal выбросывает исключение при переполнении в любом случае (даже если есть unchecked)

	@ Литералы:

		• Литералы бывают логическими, целочисленными, вещественными, символьными и строчными:

			Логические: 	true, false
			Целочисленные: 	2, 5, 10, -7, -93
			Символьные:		'2', 'A', 'T'

			• Строковые:

				"фыва", "Hello World"

				• Двойная кавычка в строке: " Компания \"Рога и копыта\" "
				& Перед строкой можно поставить знак $ и после этого в фигурных скобках мы можем вводить значения переменных:

					int age = 27;
					bool isEmployed = true;

					Console.WriteLine($"Возраст и имеет работу: {age}, {isEmployed}");

			• Вещественные:

				• Вещественные литералы представляют дробные числа. Этот тип литералов имеет две формы:

				& Числа с фиксированной точкой:
					3.14
					100.001
					-0.38

				& Экспоненциальная форма:
					3.2e3	//3200
					1.2E-1 	//0.12

					//регистр символа Е не имеет значения

			• Также null (пустая ссылка)

		• Целочисленные литералы рассматриваются как значения типа int
		• Вещественные литералы рассматриваются как значения типа double


		• Для указания определенного типа, к литералу присоединяется специальный суффикс:

			U - целочисленный тип без знака (можно соединять с другими суффиксами) 
			L - long
			F - float
			D - double
			М - decimal

			• Регистр не имеет значения (D/d)

		• Записи в двоичной и шестнадцатеричной форме:

			& Числа в двоичной форме предваряются символами 0b:

				0b11 		//3
				0b1011 		//11
				0b100001 	//33

				//После 0b идет набор из нулей и единиц

			& Для записи числа в шестнадцатеричной форме применяются символы 0x:

				0x0A 	//10
				0xFF 	//255
				0xA1 	//161

				//После 0x идет набор символов от 0 до 9 и от A до F

	@ Инициализация:

		• Инициализация несколько переменных одного типа: 
			int x = 5, y = 10, z = 12;

		• Переменные, являющиеся полями или структуры, если не инициализированы явно, по умолчанию обнуляются в момент создания.

		• Обычные переменные должны быть явно инициализированы в коде до появления любого оператора, в котором используются их значения.


	@ Условные операторы:

		• В C# оператор if может работать только с bool выражениями, но не с произвольными значениями вроде -1 и 0.

		• C# запрещает "сквозные" условия почти во всех случаях. (кроме goto). Компилятор обеспечивает это ограничение за счет того, что требует, чтобы за каждой частью case следовал оператор break, в противном случае он выдает ошибку.

		• Заданное выражение в операторе switch должно быть целочисленного типа (char, byte, short или int), перечислимого или же строкового

		@ Тенарный оператор:

			Выражение1 ? Выражение2 : ВыражениеЗ
	
			• Сначала вычисляется Выражение1. Если оно истинно, то вычисляется Выражение2, а полученный результат определяет значение всего выражения тенарного оператора в целом. Если же Выражение1 оказывается ложным, то вычисляется ВыражениеЗ, и его значение становится общим для всего выражения тенарного оператора

	@ Циклы:

		@ Цикл for:

			for (инициализаторы; условие; итераторы)
  			{ ... }

  			& В инициализаторов и итераторов может быть несколько
  				for (byte i = 0, j = 20; i <= j; i += 5, j -= 5)
				{ ... }
  			& Цикл for может не иметь тело и каких либо инструкций
  				int sum = 0;
            	for (int i = 1; i <= 10; sum += ++i); 
        	& Цикл for может не иметь инициализаторов и итераторов
        		int k = 0;
           		for (; k < 10 ;)
                	k++;

    	@ Цикл do while:

    		do 
    		{ 
    		... 
    		} while (условие);
	
    		• Условие цикла do while проверяется после выполнения тела цикла
    		• Циклы do while удобны в тех ситуациях, когда тело должно быть выполнено как минимум один раз

   		@ Цикл foreach:

   			foreach (ОБЪЯВЛЕНИЕ_ПЕРЕМЕННОЙ in КОЛЛЕКЦИЯ)
			{ ... }
	
			&
				//Выписываем элементы массива
				foreach (int myVar in myArr)
                	Console.WriteLine(myVar);
	
        	• Переменной каждую итерацию присваивается следующий элемент коллецкии.
        	• Цикл завершается, когда все элементы коллекции окажутся выбранными.
        	• Тип переменной цикла должен соответствовать типу элемента коллекции.
        	• Тип может обозначаться ключевым словом var (компилятор определяет тип переменной, исходя из типа элемента коллекции)
        	• foreach работает с многомерными массивами. (берет элементы последнего массива)
		

    	@ Оператор break:
	    	• Когда в теле цикла встречается оператор break, цикл завершается
	    	• Если оператор break применяется в целом ряде вложенных циклов, то он прерывает выполнение только самого внутреннего цикла.
	    	• Оператор break, выполняющий выход из оператора switch, оказывает воздействие только на этот оператор, но не на объемлющие его циклы.

    	@ Оператор continue:
	    	• Сontinue осуществляет принудительный переход к следующему шагу цикла, пропуская любой код, оставшийся невыполненным.
	    	• В циклах while и do-while оператор continue вызывает передачу управления непосредственно условному выражению, после чего продолжается процесс выполнения цикла. А в цикле for сначала вычисляется итерационное выражение, затем условное выражение, после чего цикл продолжается

	@ Методы (функции):

		@ Основное:

			mod ТИП_ВОЗВРАТА ИМЯ( ПАРАМЕТРЫ )
			{ ... }
	
			• Каждая функция должна быть частью какого-либо класса, то есть каждая функция должна быть методом.
			• Для немедленного завершения метода типа void достаточно написать return. (без значения)

			& Объявление методов не обязательно должно выполняться до того, как метод будут вызывать:

				static void func1() { func2() } //так делать можно
				static void func2() { ... }
	
			& Метод с которого начинается программа, должен иметь имя Main, и быть статическим:

				static void Main()
				{ ... }
	
		@ Сокращенная запись методов для одной инструкции:

			ОБЪЯВЛЕНИЕ_ФУНКИЦИИ => ИНСТРУКЦИЯ

			& Сокращенная запись методов используется для одной инструкции.

				void SayHello() => Console.WriteLine("Hello");

		@ Параметры:

			@ Необязательные параметры:

				static void func(int a, ТИП someVar = ЗНАЧЕНИЕ)
				{ ... }

				• Все необязательные параметры должны находиться в конце списка параметров.
		
			@ Любое кол-во параметров (params):

				static void func(params int[] myNumbers) { ... }
		
				static void Main()
				{
					func(6,12,7,9);
					func(93,15,5,7,8,1,2);
					func(); //можно и не добавлять аргументов (массив без элементов)
				}

				• params позволяет заполнять в массив-параметр, все значения аргументов в вызове метода

				& Параметр с params должен находиться последним в параметрах:

					static void func1(string myMessage, params float[] myFloats)

					//Так нельзя
					static void func1(params float[] myFloats, string myMessage)

				• В одном методе может быть только один параметр с params 
		
			@ Именованные параметры:

				someFunc(ИМЯ_ПАРАМЕТРА: ЗНАЧЕНИЕ, ИМЯ_ПАРАМЕТРА: ЗНАЧЕНИЕ, ... )
				
				&
					static void func(int a, int b) { ... }
			
					static void Main() 
					{
						int myNum = 5;
						func(b: 6, a: myNum); //в func: b=6, a=5
					}

					• Именованные параметры позволяют передавать аргументы определенным параметрам в методе

					• Передавать аргументы можно в любом порядке

	@ Ввод и вывод:

		• Методы Console (System) позволяет выполнять ввод и вывод в консоли:
			Write(str) 		- вывод без символа новой строки (\n)
			WriteLine(str) 	- вывод с символом новой строки (\n)
			ReadLine() 		- ввод


	@ Комментарии:

		// - комментарий на одной линии (однострочные)
	
		/* */ - комментарий с началом (/*) и концом (*/) (многострочные)
		&
			/* bla bla bla
			bla bla bla bla
			bla bla */
	
		• Символы комментария в строке трактуются как обычные символы.

	@ Константы и readonly:

		@ Константы:
		
			ТИП_ДОСТУПА const ТИП myVar
		
			• Сразу после объявления константы, мы должны инициализировать её
		
			• Константы неявно статические (всегда статические)
			• Мы не можем объявить константу статической, так как она уже статическая.
			• С константами можно работать в статических методах (т. к. они неявно статические)
		
			• Значение константе должно быть присвоено еще на этапе компиляции (константе нельзя присвоить значение из переменной, только магические числы, литералы)
			• Нельзя использовать результат вызова метода или непостоянный член класса, так как они не являются константными выражениями.

			• Константа может быть только значимым типом (value type)

			• Числа, логические значения и строки могут быть использованы для константы, в то время как, например, объект DateTime не может быть использован в качестве константы.

		@ readonly:

			ТИП_ДОСТУПА readonly ТИП myVar

			• Нигде кроме как в конструкторе или при объявлении присвоить значение readonly нельзя

			• Он недоступен на уровне метода, но может использоваться на уровне класса для определения поля (поле readonly сделать можно, а вот локальную переменную нет)

			• После присваивания значения readonly, изменить значение уже будет нельзя

			• readonly не обязательно присваивать значение сразу (при объявлении), мы можем присвоить значение readonly в конструкторе (но только если еще не инициализировали)

			• readonly не является неявно статическим как константа

			• Чтобы инициализировать статическое readonly поле в констукторе, нужно использовать статический конструктор

			• readonly может быть и значимым типом и ссылочным типом (value type, reference type)

	@ Операторы

		@ Арифметические операторы:

			• Арифметические операторы:

				+ 
				-
				* 
				/ 
				% 
				++ 
				--

			• Когда оператор / применяется к целому числу, то любой остаток от деления отбрасывается. (13/3=4)
			• В C# оператор % можно применять как к целочисленным типам данных, так и к типам с плавающей точкой. Поэтому 13.0 % 3.0 также равно 1.
			• Для изменения порядка следования операций применяются скобки.

			• Инкремент и декремент бывает префиксным и постфиксным:

				• Инкремент:
					• Префиксный	(++x) 	- прибавляется 1, а потом возвращается значение
					• Постфиксный 	(x++) 	- сначала возвращается значение, а затем прибавляется 1.

				• Декремент:
					• Префиксный	(--x) 	- уменьшается 1, а потом возвращается значение
					• Постфиксный 	(x--) 	- сначала возвращается значение, а затем уменьшается 1.
		
			• Приоритет операций:

				• Приоритет операций от наивысшего к низшему:

					1. Инкремент, декремент
					2. Умножение, деление, получение остатка
					3. Сложение, вычитание

		@ Операторы отношения и логические операторы:
		
			• Единственное отличие укороченного логического оператора от обычного заключается в том, что второй его операнд вычисляется только по мере необходимости.

			• Логические операторы:

				& 	- 	И
				| 	- 	ИЛИ
				^ 	-	Исключающее ИЛИ
				&& 	-	Укороченное И
				|| 	-	Укороченное ИЛИ
				! 	-	НЕ

		@ Оператор присваивания:


			• Cпособ присваивания "по цепочке":

				int x, у, z;
				x = у = z = 10;

				//Здесь значение присваивается сначала переменной z, затем переменной у и, наконец, переменной х.

			• Составные операторы присваивания:

				+=,	-=		(сложение, вычитание)

				*=	/= 	%=	(умножение, деление, деление по модулю)

				&=	|=	^= 	(побитовые оператор)

		@ Ассоциативность операторов:

			• Когда операции имеют один и тот же приоритет, порядок вычисления определяется ассоциативностью операторов. Есть два типа операторов:

					• Левоассоциативные операторы, которые выполняются слева направо
					• Правоассоциативные операторы, которые выполняются справа налево
					
			& Все арифметические операторы являются левоассоциативными, то есть выполняются слева направо:

					10 / 5 * 2 = 4

					//Выражение 10 / 5 * 2 необходимо трактовать как (10 / 5) * 2

			& Операции присвоения являются правоассоциативными, то есть выполняются справа налево:

				int a = 8;
				int b = 6;
				int c = a += b -= 5;    // 9




@ Массивы:

	@ Основное

		mod ТИП [] array
		mod ТИП [] array = new ТИП [ КОЛ-ВО ЭЛЕМЕНТОВ ]
		&
			int[] myNumbers;
			int[] myNumbers = new int[3]
	
		• Массив - это класс (ссылочный тип), поэтому ему нужно выделять место с помощью new:
	
			ТИП [] array = new ТИП [ КОЛ-ВО ЭЛЕМЕНТОВ ]
			&
				int[] myArr;		//создаем ссылку
				myArr = new int[6]; //присваиваем ссылке массив с 6-ю элементами
	
		• Инициализация массива:
	
			ТИП [] array = new ТИП [ КОЛ-ВО ЭЛЕМЕНТОВ ] { ИНИЦИАЛИЗАЦИЯ }
			& int[] myArr = new int[3] { 7,2,0 }
	
			• Если кол-во элементов указано и происходит инициализация, то все элементы должны быть инициализированы.
	
			& Можно указать инициализацию, а остальное компилятор сделает сам:
	
				ТИП [] array = { ИНИЦИАЛИЗАЦИЯ }
				& int[] myArr = {8, 3, 0, -4, 5} //массив типа int, имеет 5 элементов
	
			• Также, можно указать только тип или только new если происходит инициализация. Все следующие варианты доступны:
	
				//тип
				ТИП [] array = new ТИП[] { ИНИЦИАЛИЗАЦИЯ }
	
				//new
				ТИП [] array = new[] { ИНИЦИАЛИЗАЦИЯ }

		& В случае определения массива объектов (тип object) находящиеся внутри него элементы могут представлять собой что угодно:
		
			object[] arrByObject = { true, 10, "Привет", 13.7m }; 
			//такой массив называестя массивом объектов

		** Особенности:

			• Если массив только объявляется c выделенным местом, но явно не инициализируется, каждый его элемент будет установлен в значение, принятое по умолчанию для соответствующего типа данных.
		
			• Можно также определять неявно типизированные локальные массивы с помощью var (тип будет определятся от элементов)
	
			• Если индекс будет вне массива, то выбросится исключение IndexOutOfRangeException
	

			• Массивы реализованы в виде объектов
	
			• Для тoго чтобы воспользоваться массивом в программе, требуется двухэтапная процедура, поскольку в C# массивы реализованы в виде объектов. Во-первых, необходимо объявить переменную, 	которая может обращаться к массиву. И во-вторых, нужно создать экземпляр массива, используя оператор new.


	• Класс Enumerable с массивами:

		• Enumerable.МЕТОД().ToArray() - cоздает определенный массив который можно присвоить другому массиву:

			ТИП[] array = Enumerable.МЕТОД.ToArray()
			& int[] myArr = Enumerable.Repeat(5,10).ToArray() //массив с десятью элементами имеющие значение 5

		• Методы Enumerable:

			Repeat(%,%) - заполняет элементы значением - первый параметр 
			Range(%,%) - первый параметр, стартовое число, следующим элементам прибавляется 1 ( 7,8,9,10 ... )

			• Второй параметр этих методов это кол-во элементов массива

	• Нахождение макс, мин числа:

    	using System.Linq;

    	int[] myArr = { 0, 2, -3 }
    	int max = myArr.Max(); //возврат макс. числа в массиве
    	int min = myArr.Min(); //возврат мин. числа в массиве
    	int sum = myArr.Sum(); //возврат суммы всех элементов массива

    	• Все эти методы находятся в пространстве имен System.Linq

    • Члены массива:

		Length - длина массива 				//свойство
		GetType() - получить тип массива


	@ Многомерный массив:

		ТИП[ ЗАПЯТЫЕ ] array
		&
			//двухмерный массив
			int[,] arrayGrid =
			{
				{3,6},
				{5,8}
			};

			//трехмерный массив
			int[,,] arrayGrid =
			{
				{ {6,8}, {0,9} },
				{ {5,2}, {9,1} }
			};

		• Кол-во запятых означает кол-во измерений

		• Выделение места многомерному массиву:

			ТИП[ ЗАПЯТЫЕ ] array = new ТИП[ КОЛ-ВО ЭЛЕМЕНТОВ 1-ГО ИЗМЕРЕНИЯ, КОЛ-ВО ЭЛЕМЕНТОВ 2-ГО ИЗМЕРЕНИЯ , ... , КОЛ-ВО ЭЛЕМЕНТОВ ]
			& 
				int[,] someGrid = new int[3,5] //двухмерный
				char[,,,] emptyGrid = new char[4,3,5,2] //четырёхмерный

		• Получение элемента многомерного массива:

			array[ ИЗМЕРЕНИЕ1 , ИЗМЕРЕНИЕ2 , ... , ЭЛЕМЕНТ ]
			&
				someGrid[2,1] //двухмерный
				arrayGrid[8,0,3] //трехмерный

		• Инициализация многомерного массива:

			ТИП[ ЗАПЯТЫЕ ] someArray = new ТИП[ КОЛ-ВО ЭЛЕМЕНТОВ 1-ГО ИЗМЕРЕНИЯ, ... , КОЛ-ВО ЭЛЕМЕНТОВ ]
			{
				{ ... },
				{ ... },
				...
				{ ... },
			};

			&
				//двухмерный
				int[,,] myNumbers = new int[3,5]
				{
					{ 7,5,3,8,9   },
					{ 10,0,-2,4,1 },
					{ 3,2,12,75,4 }
				};

				//трехмерный
				int[,,] myNumbers = new int[3,2,3]
				{
					{ {2,9,3}, {6,1,7} },
					{ {1,6,3}, {4,3,3} },
					{ {3,1,7}, {2,1,8} }
				};

			& Можно указать инициализацию, а остальное компилятор сделает сам:

				ТИП [,] array = { ИНИЦИАЛИЗАЦИЯ }
				& int[,] myArr = { {5,3,6}, {9,4,1} } //двумерный массив типа int, имеет 2 массива, с 3-мя элементами

			• Также, можно указать только тип, если происходит инициализация:

				ТИП [,] array = new ТИП[,] { ИНИЦИАЛИЗАЦИЯ }
				& int[,] myArr = new int[,] { {2,6} , {7,4} , {1,9} }


			• Для инициализации многомерного массива достаточно заключить в фигурные скобки список инициализаторов каждого его размера

		& GetLength( ИЗМЕРЕНИЕ ) - позволяет узнать кол-во элементов в определенном измерении:

			int[,] array = 
			{ 
				{7,2,9}, 
				{2,6,3} 
			}

			int height = array.GetLength(0); //2, так как два массива
			int width = array.GetLength(1); //3, так как массивы имеют три элемента


		@ Ступенчатый (зубчатый) массив:

			ТИП[][] stairArr = new ТИП[ КОЛ-ВО МАССИВОВ ][];
			& int[][] myArr = new int[4][];
	
			• Ступенчатый массив - специальный тип двумерного массива, представляет собой массив массивов, в котором длина каждого массива может быть разной.

			• Инициализация:
	
				myArr[0] = new int[4]; //первый массив, будет иметь длину 4 
        	    myArr[1] = new int[6]; //второй массив, будет иметь длину 6
        	    myArr[2] = new int[3]; //третий массив, будет иметь длину 3 
        	    myArr[3] = new int[4]; //четвертый массив, будет иметь длину 4
	
        	• Получение доступа к элементам:
	
        		array[ МАССИВ ][ ЭЛЕМЕНТ МАССИВА ] 

        	• В Rank его измерение будет 1, так как он не является двумерным массивом, скорее одномерным массивом одномерных массивов

        	• Если не инициализировать массивы памятью, то по дефолту они будут null, так как это дефолтное значения для ссылочных типов
	
        	• Особый случай представляет применение свойства Length при обращении со ступенчатыми массивами. В этом случае с помощью данного свойства можно получить длину каждого массива, составляющего ступенчатый массив.


    @ Класс Array:

    	• Класс Array является абстрактным, нельзя создавать экземпляры

    	• Класс Array является базовым классом для массивов: методы и свойства, определенные в классе Array, можно использовать с любым массивом C#

    	• Так как Array является классом и является базовым классом для массивов, по этой причине массивы - ссылочные типы (ведь они классы)

    	• Экземпляры массивов возможно создавать с помощью статического метода CreateInstance(%,%):

    		Array myArr = Array.CreateInstance(typeof(string),5);

    		• Первый параметр это тип элементов массива, его можно передать как объект Type.
    		• Второй параметр это размер массива

    	• Для установки значений в массив Array служит метод SetValue(%,%), а для их чтения — метод GetValue():

    		myArr.SetValue("Name",0);
            myArr.SetValue("Age",1);

            string s = (string)myArr.GetValue(1);
            //преобразуем в string потому что GetValue() возвращает object

            • Первый параметр SetValue() это значение
            • Второй параметр SetValue() это индекс

            • GetValue() возвращает значения типа object

        @ Копирование массивов:

        	• Поскольку массивы — это ссылочные типы, присваивание массива другому массиву создает две переменных, ссылающихся на один и тот же массив.

        	• Метод Clone(), определенный в интерфейсе ICloneable, создает неглубокую копию массива:

        		string[] arr1 = (string[])arr2.Clone();
        		//преобразуем в string[] потому что Clone() возвращает object

        		• Если элементы массива относятся к типу значений, то все они копируются, если массив содержит элементы ссылочных типов, то сами эти элементы не копируются, а копируются лишь ссылки на них.

        		• Clone() возращает тип object, поэтому происходит преобразование в string[]

        	• Можно также применять метод Array.Сору(%,%,%), тоже создающий поверхностную копию, но который требует наличия существующего массива той же размерности с достаточным количеством элементов:

        		string[] arr1 = new string[3]
        		string[] arr2 = { "ab", "cd", "ef" }

        		Array.Copy(arr2, arr1, arr2.Length);

        		• Первый параметр это массив из которого мы копируем данные
        		• Второй параметр это массив в который мы вставляем данные
        		• Третий параметр это размер

        @ Функционал Array:

        	@ Сортировка и поиск:
	
        		• В классе Array реализован алгоритм быстрой сортировки (Quicksort) элементов массива c помощью метода Sort(%):

        		int[] myArr = {9, -7, 2}
        		Array.Sort(myArr)

        		// myArr после Sort: -7, 2, 9
        		

        		• Метод Sort() требует от элементов реализации интерфейса IComparable. Простые типы, такие как System.String и System.Int32, реализуют IComparable, так что можно сортировать элементы, относящиеся к этим типам.

        		? С помощью разных вариантов метода Sort() можно отсортировать массив полностью или в заданных пределах либо отсортировать два массива, содержащих соответствующие пары "ключ-значение"
	
        		• После сортировки в массиве можно осуществить эффективный поиск, используя разные варианты метода BinarySearch(%,%):
	
        			int search = Array.BinarySearch(myArr, 12);
	
        			• Первый параметр это массив
        			• Второй параметр это значение индекс которого мы хотим найти.
	
        			• BinarySearch возвращает индекс найденного числа в массиве, если одинаковых чисел несколько, то он вернет индекс числа, которое находится на середине. (из-за алгоритмов поиска)

        	• Перевернуть все элементы в массиве (поставить в обрат. порядке) - Array.Reverse( МАССИВ )


    @ Индексы и диапазоны:

    	@ Индексы:

    		array[^ИНДЕКС]
	
    		• ^ означает, что индекс будет выбираться с конца (начало с 1 а не с 0, ^0 - невозможно)

    	@ Диапазоны:
	
    		array[ ИНДЕКС1..ИНДЕКС2 ] //две точки - синтаксис
	
    		& Возвращает диапазон элементов между первым индексом и элементом перед вторым индексом

    			int[] myArr = { 0, -4, 7, 3, 2 }
    			myArr[1..3] //элементы -4 и 7
	
    			int[] secondArr = myArr[..4] // 0, -4, 7, 3

    			int[] thirdArr = myArr[..^1] // 0, -4, 7, 3
	
    		• Если не указать первый индекс (..ИНДЕКС2), то диапазон будет начинаться с начала массива,
    		• Если не указать второй индекс (ИНДЕКС..), то диапазон будет заканчиваться в конце массива
    		• Если не указывать индексы (..), то диапазон будет захватывать все элементы.
	
    		• Диапазоны не возвращают ссылки на элементы массива, они копируют сами значения!
    		• Копирование массива при помощи диапазона: int[] myArr2 = myArr[..]

    		& Диапазоны и индексы можно комбинировать:

    			myArr[^2..]
    			myArr[..^3]
    			myArr[2..^4]
    			myArr[^5..^2]

    		& Диапазоны можно использовать в foreach цикле:

    			foreach(int num in myArr[2..5])
    			{ ... }

@ Классы и объекты:
	
	@ Основное:

		class Book
		{ ... }

		• Объектам класса нужно выделять память с помощью new (т.к. класс - ссылочный тип)
	
		• Создание объектов:

			КЛАСС object = new КОНСТРУКТОР_КЛАССА( ... )
			& Book mybook = new Book()
	
		& Каждый член класса имеет тип доступа (public, private), он пишется перед типом.
	
			public int a;
			private void myFunc() { ... }
	
		• Если не вписать тип доступа, то по умолчанию будет private
	
	
		• Так как абсолютно все типы данных в С# наследуются от object, то наши классы не исключения, поэтому каждый созданный нами класс будет иметь методы object.
	
	@ Нюансы копирования классов:

		• Так как классы ссылочные типы, ссылку на класс можно спокойно передавать в методы. (не происходит копирования класса, происходит копирование ссылки на класс)
	
		• Так как классы ссылочные типы, копирование классов при присваивании не происходит. Происходит копирование ссылок на один и тот же класс!:

			Book book1 = new Book();
			Book book2 = book1; //не копирование класса, а копирование ссылки


		• Чтобы скопировать класс, нужно создать конструктор который принимает тот же класс , и в конструкторе задать полям класса поля копируемого класса:

			public Book(Book book)
			{
				title = book.title
				pages = book.pages
				...
			}

	@ Синтаксис инициализации объектов:

		КЛАСС myClass = new КОНСТРУКТОР( ПАРАМЕТРЫ ) 
		{ 
			ПОЛЕ1 = ЗНАЧЕНИЕ,
			ПОЛЕ2 = ЗНАЧЕНИЕ,

			ВЛОЖЕННЫЙ_КЛАСС = new КОНСТРУКТОР_ВЛОЖЕННОГО_КЛАССА( ПАРАМЕТРЫ )
			{
				ПОЛЕ1 = ЗНАЧЕНИЕ,
				ПОЛЕ2 = ЗНАЧЕНИЕ,
				...			
			},

			...
		}

		• После конструктора идет инициализация, пишутся поля и присваиваемые им значения

		• Поля должны быть разделены запятыми

		• Если в классе есть публичный класс, то синтаксис у этого вложенного класса будет такой же

		• Сначала вызывается конструктор, а потом происходит инициализация

		• Круглые скобки можно не писать, без них будет вызыватся конструктор по умолчанию (конструктор без параметров)

	@ Конструкторы:

		ТИП_ДОСТУПА НАЗВАНИЕ_КЛАССА( ... )
		{ ... }

		• Можно использовать тип доступа private для синглтона

	@ Геттеры и сеттеры:

		• Свойство - специальный метод для определения геттеров и сеттеров:

			ТИП_ДОСТУПА ТИП_ВОЗВРАТА Number
			{
				ТИП_ДОСТУПА get { ... } //геттер
				ТИП_ДОСТУПА set { ... } //сеттер
			} 
			&
				public string Name
				{
					get { return name; } //представим что у нас есть переменная строка name
					set 
					{ 
						if(value != "Arthur")
							name = value;
						else
						{
							Console.WriteLine("Плохое имя!");
							name = "DefaultName";
						}
					}
				} 

		• Исползование свойства:

			public string Title
			{
				get { return title;  }
				set { title = value; }
			}

			Book book = new Book();

			string myTitle = book.Title; //геттер

			book.Title = "Harry Potter"; //сеттер


			• Выполняется обращение к свойствам

		& В сеттере свойства, значение, которое хочет задать программист переменной, обозначается value.

			public int Number
			{
				get {...}
				set { myNumber = value } //самой простой сеттер, без условий и.т.д.
			}

		• По умолчанию тип доступа у аксессоров (get,set) будет такой же как и у свойства

		• Можно включать get и set отдельно (только set, только get):

			public int Property { get { ... } }
			public int Other { set { ... } }

		? Автоматические свойства:

			ТИП_ДОСУТПА ТИП Property { ТИП_ДОСУТПА get; ТИП_ДОСУТПА set; }

			• Приватное поле автоматически создаётся.

			• Автоматические свойства нужны если нам вдруг потом нужно добавить логику для аксессоров

			• Можно включать get и set отдельно (только set, только get)

	@ Всё статическое (static):

		@ Статические члены (члены пренадлежащие классу):

			Переменная - 	ТИП_ДОСТУПА static ТИП global_id
			Метод -			ТИП_ДОСТУПА static ТИП_ВОЗВРАТА getGlobalID() { ... }
	
			• Получение доступа к статическому члену: НАЗВАНИЕ_КЛАССА.global_id
	
			• В статических методах мы не можем использовать нестатические члены класса
			• В статических методах мы можем использовать статические члены класса
			• В нестатических методах мы можем использовать статические члены класса
	
			& Вместо this для получения поля объекта, можно использовать название класса для получения статического поля:
	
				//имя класса - MyClass
				private static int x;
	
				public void myFunc(int x)
				{
					MyClass.x = x;
					//MyClass.x - статическое поле класса; x - параметр
				}

		@ Статический конструктор:

			static НАЗВАНИЕ_КЛАССА() { ... }

			• Статический конструктор вызывается в тот момент когда мы хоть как то пытаемся взаимодействовать с классом в котором есть этот статический конструктор

			• Статический конструктор во время работы всей программы вызывается только один раз

			• В классе может быть только один статический конструктор

			• Статический конструктор не может принимать параметры

			• Нет модификатора доступа

			• В статическом конструкторе мы не можем использовать нестатические члены класса
			• В статических конструкторе мы можем использовать статические члены класса

		@ Статические классы:

			static class Tools { ... }

			• Статические классы - классы, объекты которых нельзя создавать.

			• В статических классах мы не можем использовать нестатические члены
			• В статическом классе мы можем использовать только статический конструктор 

	@ extension методы:

		public static void myFunc(this ТИП myVar, ПАРАМЕТРЫ )
		{ ... }

		• extension методы позволяют добавить новый функционал к уже существующим классам или структурам, при этом не модифицируя сами классы или структуры.

		& extension метод должен находится в статическом классе, и должен быть статическим:

			static class myExtensions
			{
				public static void Print(this DateTime dateTime) //extension метод
			}

		& Чтобы указать для чего мы пишем extension метод, мы используем первый параметр:

			public static void Print(this DateTime dateTime)
			{ ... }

			• DateTime - структура C#, пишем extension метод для неё

		• После первого параметра идут обычные параметры

		& Использование extension метода: 

			static class myExtensions
			{
				public static void Print(this DateTime dateTime) //используется этот extension метод
				{
					Console.WriteLine(dateTime);  
				}
			}

			static void Main()
			{
				DateTime currentTime = DateTime.Now;
				currentTime.Print();
			}

			• Мы как-бы добавили метод в структуру DateTime, но на самом деле нет

		• extension методы можно использовать с любой структурой или нестатическим классом (допустим с классом из библиотеки)

	@ partial классы:

		partial class Book 
		{ ... }

		• partial позволяет код класса разделить в разные файлы

		& Все классы должны быть определены с помощью ключевого слова partial и иметь одинаковые имена:

			File1.cs:

				partial class Book //одна часть класса (допустим поля)
				{ ... }

			File2.cs:

				partial class Book //другая часть класса (допустим методы)
				{ ... }

		• Компилятор будет воспринимать все части класса как один класс

	@ this и делегирующие конструкторы:

		& this - ссылка к текущему экзампляру класса:

			private int x;

			public void myFunc(int x)
			{
				this.x = x; 
				//this.x - поле класса; x - параметр
			}

		• Вызов конструктора в конструкторе (делегирующие конструкторы):

			public Book(string title, int pages) : this(title) //выбираем нужный конструктор

	@ Отдельный файл для класса:

		namespace ИМЯ
		{
			class Book { ... }
		}

		• Имя пространства может быть одним и тем где находится класс с Main-ом и наш класс уже можно будет использовать в основном файле, но если это не так то нужно использовать using ИМЯ_ПРОСТРАНСТВА для получения доступа к нашему классу.

		• Никаких include-ов нет, это не C++, все файлы это всё единственный код, всё зависит от пространтсва имён

@ ООП:

	@ Наследование:

		@ Основное:

			class НАЗВАНИЕ_КЛАССА : НАЗВАНИЕ_БАЗОВОГО_КЛАССА 
			{ ... }

			• Любой тип (класс) можно сохранить в ссылке базового класса:

				Parent myClass = new Child()
				Grandparent myClass = new Parent()
				Grandparent myClass = new Child()
	
				//Но дочерний не может иметь базовый класс
				//Так нельзя
				Child myClass = new Parent()
	
			• Ссылка базового класса на дочерний класс может пользоваться только тем, что реализовано в базовом классе (ссылка как бы указывает на часть базового класса у наследника)

			• Чтобы использовать функционал дочернего класса в ссылке базового класса, нам нужно выполнить явное приведение ссылки базового класса в ссылку дочернего классого. (Читать главу 2)

			** Особенности

				• Мы не можем использовать неявное приведение ссылки базового типа в нужный дочерний тип, так как ссылка может ссылаться на другие дочерние классы, не на тот класс который нам нужен.

					//Так нельзя (нужно явное приведение)
					Parent parent = new Child()
					Child child = parent

					//Правильно (с явным приведением)
					Parent parent = new Child()
					Child child = (Child)parent

					• Явное приведение мог бы выбросить исключение, если parent не являлся ссылкой на Child, в этом вся проблема явного приведения.

					• Лучше всего использовать as и is вместо явного приведения (Глава 2)

				• Присвоение наследника в ссылку базового класса, является неявным приведением:

					Parent myClass = new Child() //неявное приведение
	
				• Наследник одновременно является и родительским классом
		
				• Множественное наследоване в С# запрещено

		@ base - ссылка на базовый класс (вызов род. конструктора):

			& Пример:

				class Parent
				{
					public int myVar;
				}
	
				class Child : Parent
				{
					public Child()
					{
						base.myVar = 5;
						//base можно и не писать, myVar = 5;
					} 
				}

			• Вызов родительского конструктора:

				class Parent 
				{
					public Parent(ПАРАМЕТРЫ) //будет вызываться этот конструктор
					{ ... }
				}
	
				class Child : Parent
				{
					public Child() : base(ПАРАМЕТРЫ)
					{ ... }
				}

		@ Приведение базового класса в дочерний класс (as, is):

			@ as:

				ТИП child = ОБЪЕКТ as ТИП
				&

					Parent parent = new Child()
					Child child = parent as Child

					//Так как дочерние классы тоже являются базовыми типами то такая схема работает 

				• as преобразовывает объект в тип, если возможно, иначе возращает null

				• Если объект является указанным типом, то выполняется приведение типа
				• Если объект не является указанным типом, то возвращается null

			@ is:

				ОБЪЕКТ1 is ТИП ОБЪЕКТ2

				• is возвращает, является ли объект указанным типом или нет.

				• Объект2 не обязателен, можно не писать

				• Если объект1 является указанным типом, то возвращается true и объект2 (если указан) присваивается приведенный объект1
				• Если объект1 не является указанным типом, то возвращается false и объект2 (если указан) присваивается null

		@ Переопределение методов в дочернем классе:

			class Parent
			{
				ТИП_ДОСТУПА virtual ТИП_ВОЗВРАТА Print() { ... }
			}

			class Child : Parent
			{
				ТИП_ДОСТУПА override ТИП_ВОЗВРАТА Print () { ... }
			} 

		@ Виртуальные методы и свойства:

			• Те методы и свойства, которые мы хотим сделать доступными для переопределения, в базовом классе помечается модификатором virtual

			• А чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором override.

			&

				class Person
				{
					public virtual void Print()
					{

					}
				}

				class Employee : Person
				{

					public override void Print()
					{
						Console.WriteLine($"{Name} работает в {Company}");
					}
				}

		• protected - модификатор доступа, поля которого, доступны только в наследниках

	@ Модификаторы доступа:
	
		public - доступен везде

		protected - доступен только в наследниках

		private - нигде не доступен

		• Класс может использовать свои поля, методы и.т.д независимо от их модификаторов доступа

		• Картинка D:\Files\C#\модификаторы_доступа.png

@ Значимые и ссылочные типы (стек и куча):

	@ Основное:

		• Где находятся:

			• Значимые типы  (value types) 	находятся в стеке
			• Ссылочные типы (reference types) 	находятся в куче

		• Чем являются:

			• Значимые типы - структуры (struct), перечисления (enum)
			• Ссылочные типы - классы (class)

		• Существование:

			• Значимые типы прекращают свое существование, когда выходят из (своей) области видимости
			• Ссылочные типы прекращают свое существование, когда объект подвергается сборке мусора

		• Копирование:

			• Значимые типы при копировании, передаются по значению (копируются реальные данные)
			• У ссылочных типов при копировании, копируется ссылка, оригинал и копия ссылаются на один и тот же объект в куче


		• Структуры:

			• Все целочисленные типы 
			• Типы с плавающей точкой 
			• char 
			• bool

			• В кратце, всё, кроме string и object.

		• Классы:

			• Массивы (т.к. базовый класс Array, значит сам класс)
			• string
			• object

	@ Передача по ссылке:

		@ ref:

			static void func(ref int myParam) { ... }

			static void Main()
			{
				int myVar = 5;
				func(ref myVar);
			}

			• Переменная myVar передалась по ссылке в метод func
			• В аргументе и в параметре перед типом переменной пишем ref

		@ out:

			static void func(out int myParam) 
			{
				myParam = 10; 
			}

			static void Main()
			{
				int myVar; //можно и без инициализации
				func(out myVar);
			}

			• То же самое что и ref, только в методе переменная обязательно должна быть инициализирована (внутри метода переменная мы обязаны присвоить ей значение)

			& Также внутри аргумента вызова метода, можно объявить переменную с out:

				static void func(out int myParam) 
				{
					myParam = 10;
				}

				static void Main()
				{
					func(out int myVar);
					Console.WriteLine(myVar);
				}

		@ in:


			static void func(in int myParam) { ... }

			static void Main()
			{
				int myVar = 3;
				func(myVar); //можно и без in
			}

			• То же самое что и ref, только в методе переменная не может быть изменена (только для чтения)

	@ Пустые ссылки (null):

		• null - это пустая ссылка (литерал)

		• Дефолтное значение у ссылочных типов это null

		• У значимых типов, null хранится не может

		• Если попытаться извлечь данные из ссылки, у которой null, то получим исключение NullReferenceException

		@ Оператор объеденения c null (??)

			ОПЕРАНД1 ?? ОПЕРАНД2

			• Оператор ?? возвращает операнд1, если операнд1 не равен null. Иначе возвращается операнд2.
			• Операнд1 должен быть ссылочным типом
			• Операнд2 должен быть такого же типа, как и переменная.

		@ Оператор присваивания объединения со значением null (??=)

			ОПЕРАНД1 ??= ОПЕРАНД2

			• Оператор присваивает операнду1 операнд2, если операнд1 равен null.

		@ Оператор условного null (?.)

			объект?.член_объекта

			• Если объект не равен null, то происходит обращение к члену объекта - полю, свойству, методу. Если объектпредставляет значение null, обращение к члену не происходит, и возвращается null.

		@ Типы nullable:

			ТИП? myVar
			& int? myVar = null

			• Nullable типы позволяют значимым типам содержать null

			• Чтобы превратить перемнную в nullable тип, нужно добавить ? после типа

			• У nullable типа есть два дополнительных поля: HasValue и Value
				• HasValue узнает есть ли значение у переменной или содержит null
				• Value возвращает значение, но если стоит null то будет ошибка.

			• Операторы объединения работают с nullable типами

			• Арифметичесике операторы с null

				• >, < будут возвращать null в любом случае

				& При сложении, вычитании и.т.д с null в итоге вернется null:

					int a = 3
					int? b = null;

					Console.Write( a + b ) //null

@ Методы, поля разных предметов:

	• Массивы:

		Length 			- длина массива

	• string:

		Length 			- длина строки

		Contains(str) 		- если в строке есть str, то возвращает true
		IndexOf(item) 		- возвращает позицию item в строке (первый найденный), возвращает -1 если аргумента в строке нет
		Substring(index) 	- возврашает строку с index
		Remove(index) 		- возвращает строку без элементов после index

@ Перечисления:

	enum НАЗВАНИЕ : ТИП
	{ ... }

	• Можно указать тип после названия, нужно добавить двоеточие и тип.

	• Указывать тип необязательно

	• Enum.IsDefined(%,%) проверяет входит ли в диапазон перечисления определнное значение:

		enum Bla { One, Two, Three }

		Enum.IsDefined(typeof(Bla), 2) //true, 2 это Three в перечеслении

		Enum.IsDefined(typeof(Bla), 4) //false, 4 выходит из диапазона

		• Первый параметр это тип перечисления (нужен, для определения макс. диапазона)
		• Второй параметр это значение

	• Enum.GetValues(%) позволяет получить все значения перечисления в массиве:

		enum Color { ... }

		var values = Enum.GetValues(typeof(Color)) //массив

		foreach(var item in values) { ... }

		• Параметр это тип перечисления


@ Исключения (Незавершенно):

	try 
	{ ... }
	catch( ТИП_ИСКЛЮЧЕНИЯ exception )
	{ ... }

	• Если что-либо кидает исключения, то их можно поймать с помощью try-catch блоков (например ввод пользователя не может быть конвертирован в число, тогда появится исключение).

	• В try блок помещается код, который может выбросить исключение.

	• Если код выбросит исключение в try блоке, то catch блок с подходящим типом поймает исключение, и в него переходит выполнение кода.

	• catch блокам можно указать ловить определенный тип исключения. Если не указать тип исключения, то catch блок будет ловить любые исключения.

	• catch блоков может быть несколько.

	
@ Сниппеты Visual Studio:
	
	ctor 		- создаёт конструктор для класса
	propfull 	- создаёт переменную с свойством

@ Несделанные конспекты:

	Здесь приведены темы, которых я даже не касался по какой-либо причине.

	• goto - просто бесполезно
	• Поразрядные операторы (<<, >>) - пока что ненужно, очень редко используются
	• Трехмерные и более мерные зубчатые массивы - пока что ненужно, очень редко используются
	• partial методы - старанная штука, бесполезна

@ Другое:

	& Если есть две перемнные с одним именем, но они находятся в разных областях видимости, то внутри области видимости будет использоватся та переменная, которая была создана в той же области видимости:

		class Program
    	{
      		static int j = 20;
      		public static void Main()
       		{
        		int j = 30;
        		Console.WriteLine(j); //выведется 30, а не 20 (используется j в методе Main)
       		}
    	}

	• C# делает принципиальное различие между полями и обычными переменными. 
	В данном случае новая переменная с именем j, объявленная в методе Main(), скрывает переменную уровня класса с тем же именем:

		class Program
    	{
      		static int j = 20;
      		public static void Main()
       		{
        		int j = 30;
        		Console.WriteLine(j); //выведется 30, а не 20 (используется j в методе Main)
       		}
    	}

    @ Вспомогательные классы:

		• Все методы этих классов статические
		• Класс Console и Convert находятся в пространстве имен System.
		• Методы Math нужны для математики, такие как Abs, Pow, Sqrt, Max, Mi